<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RandomSearch.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Test-Suite-Minimisation</a> &gt; <a href="index.source.html" class="el_package">de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms</a> &gt; <span class="el_source">RandomSearch.java</span></div><h1>RandomSearch.java</h1><pre class="source lang-java linenums">package de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms;

import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.ChromosomeGenerator;
import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.TestSuiteChromosome;
import de.uni_passau.fim.se2.sbse.suite_minimisation.fitness_functions.FitnessFunction;
import de.uni_passau.fim.se2.sbse.suite_minimisation.stopping_conditions.StoppingCondition;
import de.uni_passau.fim.se2.sbse.suite_minimisation.utils.Randomness;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static java.util.Objects.requireNonNull;

public class RandomSearch implements GeneticAlgorithm&lt;TestSuiteChromosome&gt; {

    private final StoppingCondition stoppingCondition;
    private final ChromosomeGenerator&lt;TestSuiteChromosome&gt; generator;

    private final FitnessFunction&lt;TestSuiteChromosome&gt; sizeFF;      // minimizing
    private final FitnessFunction&lt;TestSuiteChromosome&gt; coverageFF;   // maximizing

    // Needed for greedy seed
    private final boolean[][] coverageMatrix;
    private final int numberTestCases;
    private final int numberLines;

    public RandomSearch(
            StoppingCondition stoppingCondition,
            ChromosomeGenerator&lt;TestSuiteChromosome&gt; generator,
            FitnessFunction&lt;TestSuiteChromosome&gt; sizeFF,
            FitnessFunction&lt;TestSuiteChromosome&gt; coverageFF,
            boolean[][] coverageMatrix,
            int numberTestCases,
            int numberLines
<span class="fc" id="L36">    ) {</span>
<span class="fc" id="L37">        this.stoppingCondition = requireNonNull(stoppingCondition);</span>
<span class="fc" id="L38">        this.generator = requireNonNull(generator);</span>
<span class="fc" id="L39">        this.sizeFF = requireNonNull(sizeFF);</span>
<span class="fc" id="L40">        this.coverageFF = requireNonNull(coverageFF);</span>

<span class="fc" id="L42">        this.coverageMatrix = requireNonNull(coverageMatrix);</span>
<span class="fc" id="L43">        this.numberTestCases = numberTestCases;</span>
<span class="fc" id="L44">        this.numberLines = numberLines;</span>
<span class="fc" id="L45">    }</span>


    @Override
    public List&lt;TestSuiteChromosome&gt; findSolution() {
<span class="fc" id="L50">        notifySearchStarted();</span>

<span class="fc" id="L52">        List&lt;TestSuiteChromosome&gt; paretoFront = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L53">        TestSuiteChromosome template = generator.get();</span>

        // (A) Always include full suite (anchors coverage end)
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (!searchMustStop()) {</span>
<span class="fc" id="L57">            boolean[] all = new boolean[numberTestCases];</span>
<span class="fc" id="L58">            Arrays.fill(all, true);</span>
<span class="fc" id="L59">            evaluateAndInsert(new TestSuiteChromosome(all, template.getMutation(), template.getCrossover()), paretoFront);</span>
        }

        // (B) Greedy prefixes: add best gain test iteratively, evaluate EACH prefix
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (!searchMustStop()) {</span>
<span class="fc" id="L64">            addGreedyPrefixes(template, paretoFront);</span>
        }

        // (C) Best-K singletons (instead of ALL singletons)
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        if (!searchMustStop()) {</span>
<span class="fc" id="L69">            int K = Math.min(20, numberTestCases);</span>
<span class="fc" id="L70">            int[] best = topKSingleTestsByCoverage(K);</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">            for (int idx : best) {</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">                if (searchMustStop()) break;</span>
<span class="fc" id="L73">                boolean[] single = new boolean[numberTestCases];</span>
<span class="fc" id="L74">                single[idx] = true;</span>
<span class="fc" id="L75">                evaluateAndInsert(new TestSuiteChromosome(single, template.getMutation(), template.getCrossover()), paretoFront);</span>
            }
        }

        // (D) Budget-efficient stratified random sampling until stop
<span class="fc bfc" id="L80" title="All 2 branches covered.">        while (!searchMustStop()) {</span>
<span class="fc" id="L81">            boolean[] genes = sampleByTargetSize();</span>
<span class="fc" id="L82">            evaluateAndInsert(new TestSuiteChromosome(genes, template.getMutation(), template.getCrossover()), paretoFront);</span>
<span class="fc" id="L83">        }</span>

<span class="fc" id="L85">        return paretoFront;</span>
    }

    private void addGreedyPrefixes(TestSuiteChromosome template, List&lt;TestSuiteChromosome&gt; paretoFront) {
<span class="fc" id="L89">        boolean[] genes = new boolean[numberTestCases];</span>
<span class="fc" id="L90">        boolean[] covered = new boolean[numberLines];</span>

<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        while (!searchMustStop()) {</span>
<span class="fc" id="L93">            int bestTest = -1;</span>
<span class="fc" id="L94">            int bestGain = 0;</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">            for (int t = 0; t &lt; numberTestCases; t++) {</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">                if (genes[t]) continue;</span>

<span class="fc" id="L99">                int gain = 0;</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                for (int line = 0; line &lt; numberLines; line++) {</span>
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">                    if (!covered[line] &amp;&amp; coverageMatrix[t][line]) gain++;</span>
                }
<span class="fc bfc" id="L103" title="All 2 branches covered.">                if (gain &gt; bestGain) {</span>
<span class="fc" id="L104">                    bestGain = gain;</span>
<span class="fc" id="L105">                    bestTest = t;</span>
                }
            }

<span class="pc bpc" id="L109" title="2 of 4 branches missed.">            if (bestTest == -1 || bestGain == 0) break;</span>

<span class="fc" id="L111">            genes[bestTest] = true;</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            for (int line = 0; line &lt; numberLines; line++) {</span>
<span class="fc" id="L113">                covered[line] |= coverageMatrix[bestTest][line];</span>
            }

            // Evaluate current prefix suite (THIS is the key improvement)
<span class="fc" id="L117">            evaluateAndInsert(new TestSuiteChromosome(genes.clone(), template.getMutation(), template.getCrossover()), paretoFront);</span>

            // Optional: stop if full coverage achieved
<span class="fc" id="L120">            boolean done = true;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            for (boolean b : covered) {</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">                if (!b) { done = false; break; }</span>
            }
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            if (done) break;</span>
<span class="nc" id="L125">        }</span>
<span class="fc" id="L126">    }</span>

    private int[] topKSingleTestsByCoverage(int K) {
<span class="fc" id="L129">        int n = numberTestCases;</span>
<span class="fc" id="L130">        int[] cov = new int[n];</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        for (int t = 0; t &lt; n; t++) {</span>
<span class="fc" id="L132">            int c = 0;</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            for (int line = 0; line &lt; numberLines; line++) {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                if (coverageMatrix[t][line]) c++;</span>
            }
<span class="fc" id="L136">            cov[t] = c;</span>
        }

        // Select top K indices by cov (simple partial selection)
<span class="fc" id="L140">        int[] idx = new int[n];</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) idx[i] = i;</span>

        // Sort descending by coverage (n log n is fine for typical sizes)
<span class="fc" id="L144">        Arrays.sort(idx);</span>

<span class="fc" id="L146">        return Arrays.copyOf(idx, K);</span>
    }

    private boolean[] sampleByTargetSize() {
<span class="fc" id="L150">        int n = numberTestCases;</span>
<span class="fc" id="L151">        boolean[] genes = new boolean[n];</span>

        // Bias towards smaller suites: k = 1 + floor((r^2) * (n-1))
<span class="fc" id="L154">        double r = Randomness.random().nextDouble();</span>
<span class="fc" id="L155">        int k = 1 + (int) Math.floor(r * r * (n - 1));</span>

        // Pick k distinct indices using a partial Fisher-Yates shuffle on an index array
<span class="fc" id="L158">        int[] pool = new int[n];</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) pool[i] = i;</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">        for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L162">            int j = i + Randomness.random().nextInt(n - i);</span>
<span class="fc" id="L163">            int tmp = pool[i]; pool[i] = pool[j]; pool[j] = tmp;</span>
<span class="fc" id="L164">            genes[pool[i]] = true;</span>
        }

<span class="fc" id="L167">        return genes;</span>
    }




    @Override
    public StoppingCondition getStoppingCondition() {
<span class="fc" id="L175">        return stoppingCondition;</span>
    }

    private void evaluateAndInsert(
            TestSuiteChromosome c,
            List&lt;TestSuiteChromosome&gt; paretoFront
    ) {
        // Count exactly ONE evaluation per sampled solution (as required)
<span class="fc" id="L183">        sizeFF.applyAsDouble(c);</span>
<span class="fc" id="L184">        coverageFF.applyAsDouble(c);</span>
<span class="fc" id="L185">        notifyFitnessEvaluation();</span>

<span class="fc" id="L187">        boolean dominated = false;</span>
<span class="fc" id="L188">        List&lt;TestSuiteChromosome&gt; toRemove = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (TestSuiteChromosome p : paretoFront) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (dominates(p, c)) {</span>
<span class="fc" id="L192">                dominated = true;</span>
<span class="fc" id="L193">                break;</span>
            }
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (dominates(c, p)) {</span>
<span class="fc" id="L196">                toRemove.add(p);</span>
            }
<span class="fc" id="L198">        }</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (!dominated) {</span>
<span class="fc" id="L201">            paretoFront.removeAll(toRemove);</span>
<span class="fc" id="L202">            paretoFront.add(c);</span>
        }
<span class="fc" id="L204">    }</span>

    /**
     * Greedy seed: repeatedly add the test that covers the most currently-uncovered lines,
     * until we either cover all lines or no further improvement is possible.
     */
    private TestSuiteChromosome greedyCoverageSeed(TestSuiteChromosome template) {
<span class="nc" id="L211">        boolean[] genes = new boolean[numberTestCases];</span>
<span class="nc" id="L212">        boolean[] covered = new boolean[numberLines];</span>

        while (true) {
<span class="nc" id="L215">            int bestTest = -1;</span>
<span class="nc" id="L216">            int bestGain = 0;</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">            for (int t = 0; t &lt; numberTestCases; t++) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                if (genes[t]) continue;</span>

<span class="nc" id="L221">                int gain = 0;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                for (int line = 0; line &lt; numberLines; line++) {</span>
<span class="nc bnc" id="L223" title="All 4 branches missed.">                    if (!covered[line] &amp;&amp; coverageMatrix[t][line]) {</span>
<span class="nc" id="L224">                        gain++;</span>
                    }
                }

<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (gain &gt; bestGain) {</span>
<span class="nc" id="L229">                    bestGain = gain;</span>
<span class="nc" id="L230">                    bestTest = t;</span>
                }
            }

            // No test can improve coverage anymore
<span class="nc bnc" id="L235" title="All 4 branches missed.">            if (bestTest == -1 || bestGain == 0) break;</span>

<span class="nc" id="L237">            genes[bestTest] = true;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (int line = 0; line &lt; numberLines; line++) {</span>
<span class="nc" id="L239">                covered[line] |= coverageMatrix[bestTest][line];</span>
            }

            // Stop early if fully covered
<span class="nc" id="L243">            boolean done = true;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            for (boolean b : covered) {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (!b) {</span>
<span class="nc" id="L246">                    done = false;</span>
<span class="nc" id="L247">                    break;</span>
                }
            }
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (done) break;</span>
<span class="nc" id="L251">        }</span>

        // Ensure at least one test (your chromosome enforces it anyway, but keep it safe)
<span class="nc" id="L254">        boolean any = false;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        for (boolean g : genes) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (g) { any = true; break; }</span>
        }
<span class="nc bnc" id="L258" title="All 4 branches missed.">        if (!any &amp;&amp; numberTestCases &gt; 0) {</span>
<span class="nc" id="L259">            genes[0] = true;</span>
        }

<span class="nc" id="L262">        return new TestSuiteChromosome(</span>
<span class="nc" id="L263">                genes, template.getMutation(), template.getCrossover()</span>
        );
    }
    private boolean dominates(TestSuiteChromosome a, TestSuiteChromosome b) {
<span class="fc" id="L267">        double aSize = sizeFF.applyAsDouble(a);</span>
<span class="fc" id="L268">        double bSize = sizeFF.applyAsDouble(b);</span>
<span class="fc" id="L269">        double aCov  = coverageFF.applyAsDouble(a);</span>
<span class="fc" id="L270">        double bCov  = coverageFF.applyAsDouble(b);</span>

<span class="pc bpc" id="L272" title="1 of 4 branches missed.">        boolean notWorse = aSize &lt;= bSize &amp;&amp; aCov &gt;= bCov;</span>
<span class="fc bfc" id="L273" title="All 4 branches covered.">        boolean better   = aSize &lt; bSize || aCov &gt; bCov;</span>

<span class="fc bfc" id="L275" title="All 4 branches covered.">        return notWorse &amp;&amp; better;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>