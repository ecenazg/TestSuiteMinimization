<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoverageTracker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Test-Suite-Minimisation</a> &gt; <a href="index.source.html" class="el_package">de.uni_passau.fim.se2.sbse.suite_minimisation.utils</a> &gt; <span class="el_source">CoverageTracker.java</span></div><h1>CoverageTracker.java</h1><pre class="source lang-java linenums">/* ******************************************************************************
 * Copyright (c) 2009, 2020 Mountainminds GmbH &amp; Co. KG and Contributors
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *    Marc R. Hoffmann - initial API and implementation
 *
 * https://www.jacoco.org/jacoco/trunk/doc/api.html
 * https://www.jacoco.org/jacoco/trunk/doc/examples/java/CoreTutorial.java
 *******************************************************************************/

package de.uni_passau.fim.se2.sbse.suite_minimisation.utils;

import org.jacoco.core.analysis.Analyzer;
import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.ICounter;
import org.jacoco.core.data.ExecutionDataStore;
import org.jacoco.core.data.SessionInfoStore;
import org.jacoco.core.instr.Instrumenter;
import org.jacoco.core.runtime.LoggerRuntime;
import org.jacoco.core.runtime.RuntimeData;

import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * Measures code coverage of a class under test by a given test suite.
 */
public final class CoverageTracker {

    /**
     * Annotation with which a JUnit 5 test case is marked.
     */
<span class="nc" id="L46">    private static final Class&lt;? extends Annotation&gt; JUNIT5_TEST = org.junit.jupiter.api.Test.class;</span>

    /**
     * Default suffix appended to the name of the CUT to obtain the name of its test suite.
     */
    private static final String DEFAULT_TEST_SUFFIX = &quot;Test&quot;;

    /**
     * The class under test (often abbreviated as &quot;CUT&quot;).
     */
    private final Class&lt;?&gt; classUnderTest;

    /**
     * Name of the class under test.
     */
    private final String classUnderTestName;

    /**
     * The test suite. Consists of test cases.
     */
    private final Class&lt;?&gt; testSuite;

    /**
     * Name of the test suite.
     */
    private final String testSuiteName;

    /**
     * Method names of the test cases in the test suite.
     */
    private final String[] testCases;

    /**
     * The coverage matrix. Lazily instantiated and cached. Every line corresponds to a test case.
     * Every row corresponds to a line in the source code of the CUT. An entry in the matrix is
     * {@code true} if the corresponding test covers the corresponding line.
     */
    private final boolean[][] coverageMatrix;

    /**
     * The line numbers in the source code. Lazily instantiated and cached.
     */
    private int[] sourceLineNumbers;

    /**
     * Whether coverage has already been measured. Used for caching.
     */
    private boolean cached;

    /**
     * Creates a new instance for tracking the coverage of the given class under test by the
     * specified test suite.
     *
     * @param classUnderTest class whose coverage to measure
     * @param testSuite      corresponding test suite
     */
<span class="nc" id="L102">    public CoverageTracker(final Class&lt;?&gt; classUnderTest, final Class&lt;?&gt; testSuite) {</span>
<span class="nc" id="L103">        this.classUnderTest = Objects.requireNonNull(classUnderTest);</span>
<span class="nc" id="L104">        this.classUnderTestName = classUnderTest.getName();</span>
<span class="nc" id="L105">        this.testSuite = Objects.requireNonNull(testSuite);</span>
<span class="nc" id="L106">        this.testSuiteName = testSuite.getName();</span>
<span class="nc" id="L107">        this.testCases = getTestCases(testSuite);</span>
<span class="nc" id="L108">        this.coverageMatrix = new boolean[testCases.length][];</span>
<span class="nc" id="L109">        this.sourceLineNumbers = null;</span>
<span class="nc" id="L110">        this.cached = false;</span>
<span class="nc" id="L111">    }</span>

    /**
     * Creates a new instance for tracking the coverage of the given class under test, attempting
     * to determine the corresponding test suite automatically.
     *
     * @param classUnderTestName fully-qualified name of the class whose coverage to measure
     * @throws ClassNotFoundException if a class could not be found
     */
    public CoverageTracker(final String classUnderTestName) throws ClassNotFoundException {
<span class="nc" id="L121">        this(load(classUnderTestName), load(getTestSuiteName(classUnderTestName)));</span>
<span class="nc" id="L122">    }</span>

    /**
     * Attempts to load and return the class with the given fully-qualified name.
     *
     * @param className name of the class to load
     * @return the loaded class
     * @throws ClassNotFoundException if the class with the given name could not be found
     */
    private static Class&lt;?&gt; load(final String className) throws ClassNotFoundException {
<span class="nc" id="L132">        return Class.forName(className);</span>
    }

    /**
     * Returns the name of the test suite for the given class under test.
     *
     * @param classUnderTestName name of the class for which to return the name of its test suite
     * @return name of the test suite
     */
    private static String getTestSuiteName(final String classUnderTestName) {
<span class="nc" id="L142">        return classUnderTestName + DEFAULT_TEST_SUFFIX;</span>
    }

    /**
     * Retrieves the test cases from the given test suite.
     *
     * @param testSuite a test suite
     * @return test cases
     */
    private static String[] getTestCases(final Class&lt;?&gt; testSuite) {
<span class="nc" id="L152">        final Method[] declaredMethods = testSuite.getDeclaredMethods();</span>
<span class="nc" id="L153">        return Arrays.stream(declaredMethods)</span>
<span class="nc" id="L154">                .filter(CoverageTracker::isTestCase)</span>
<span class="nc" id="L155">                .map(Method::getName)</span>
<span class="nc" id="L156">                .sorted() // to impose a fixed order (here: lexicographical order)</span>
<span class="nc" id="L157">                .toArray(String[]::new);</span>
    }

    /**
     * Returns the test cases of the test suite this {@code CoverageTracker} was constructed with.
     * The test cases follow the same order as in the coverage matrix returned by {@code
     * getCoverageMatrix()}.
     *
     * @return the test cases
     */
    public String[] getTestCases() {
<span class="nc" id="L168">        return testCases;</span>
    }

    /**
     * Determines whether the given method is a unit test.
     *
     * @param method the method to test
     * @return {@code true} if {@code method} is a unit test, {@code false} otherwise
     */
    private static boolean isTestCase(final Method method) {
<span class="nc" id="L178">        return method.isAnnotationPresent(JUNIT5_TEST);</span>
    }

    /**
     * Returns line coverage of the CUT as coverage matrix. Hereby, every row in the matrix
     * represents a test case and every column represents a line in the CUT. An entry {@code
     * matrix[i][j] == true} indicates that test case {@code i} covers line {@code j}. The matrix is
     * rectangular.
     *
     * @return coverage matrix as described above
     * @throws Exception if an error occurred
     */
    public boolean[][] getCoverageMatrix() throws Exception {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (!cached) {</span>
<span class="nc" id="L192">            measureCoverage();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            assert isRectangularMatrix() : &quot;coverage matrix is not rectangular&quot;;</span>
<span class="nc" id="L194">            cached = true;</span>
        }

<span class="nc" id="L197">        return coverageMatrix;</span>
    }

    /**
     * Tells whether the coverage matrix is rectangular.
     *
     * @return {@code true} if rectangular, {@code false} otherwise
     */
    private boolean isRectangularMatrix() {
<span class="nc" id="L206">        boolean rectangular = true;</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">        for (int i = 0; rectangular &amp;&amp; i &lt; coverageMatrix.length - 1; ) {</span>
            // All rows in the matrix must have the same length.
<span class="nc bnc" id="L209" title="All 2 branches missed.">            rectangular = coverageMatrix[i++].length == coverageMatrix[i].length;</span>
        }
<span class="nc" id="L211">        return rectangular;</span>
    }

    /**
     * Measures the line coverage of the CUT achieved by all unit tests in the test suite.
     *
     * @throws Exception if some error occurred
     */
    private void measureCoverage() throws Exception {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        for (int i = 0; i &lt; testCases.length; i++) {</span>
<span class="nc" id="L221">            final String testCase = testCases[i];</span>
<span class="nc" id="L222">            final boolean[] coverage = measureCoverage(testCase);</span>
<span class="nc" id="L223">            coverageMatrix[i] = coverage;</span>
        }
<span class="nc" id="L225">    }</span>

    /**
     * Measures the line coverage of the CUT achieved by the specified unit test and returns a
     * boolean array. An entry in the array is {@code true} if the corresponding line was covered.
     *
     * @param testCase for which to measure coverage
     * @throws Exception if an error occurred
     */
    private boolean[] measureCoverage(final String testCase) throws Exception {
        // For instrumentation and runtime we need an IRuntime instance to collect execution data.
<span class="nc" id="L236">        final var coverageReporter = new LoggerRuntime();</span>

        // The instrumenter creates a modified version of our class under test that contains
        // additional probes for execution data recording.
<span class="nc" id="L240">        final var coverageInstrumenter = new Instrumenter(coverageReporter);</span>

        // We use a special class loader to directly load the instrumented class definitions from
        // byte[] instances.
<span class="nc" id="L244">        final var loader = new MemoryClassLoader();</span>
<span class="nc" id="L245">        instrumentAndLoad(classUnderTest, coverageInstrumenter, loader);</span>

        // Now we're ready to run our instrumented class and need to start the runtime first.
<span class="nc" id="L248">        final var runtimeData = new RuntimeData();</span>
<span class="nc" id="L249">        coverageReporter.startup(runtimeData);</span>

        // We execute the test case via Java reflection. The test suite must have benn loaded with
        // the same class loader as the class under test.
<span class="nc" id="L253">        execute(testCase, addDefinitionAndLoad(testSuite, loader));</span>

        // At the end of test execution we collect execution data and shutdown the runtime.
<span class="nc" id="L256">        final var executionData = new ExecutionDataStore();</span>
<span class="nc" id="L257">        runtimeData.collect(executionData, new SessionInfoStore(), false);</span>
<span class="nc" id="L258">        coverageReporter.shutdown();</span>

        // Together with the original class definition we can calculate coverage information.
<span class="nc" id="L261">        final var coverageBuilder = new CoverageBuilder();</span>
<span class="nc" id="L262">        final var analyzer = new Analyzer(executionData, coverageBuilder);</span>
<span class="nc" id="L263">        try (final InputStream originalCut = getClassStream(classUnderTestName)) {</span>
<span class="nc" id="L264">            analyzer.analyzeClass(originalCut, classUnderTestName);</span>
        }

        // (Just for debugging purposes: record the original line numbers of the source file.)
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (sourceLineNumbers == null) {</span>
<span class="nc" id="L269">            sourceLineNumbers = getNonEmptyLines(coverageBuilder);</span>
        }

        // Finally, we build and return the coverage array.
<span class="nc" id="L273">        return getCoverageArray(coverageBuilder);</span>
    }

    /**
     * Executes the test case part of the given test suite.
     *
     * @param testCase  the test case to execute
     * @param testSuite the test suite containing the test case
     * @throws NoSuchMethodException     if no test case with the given name or no default
     *                                   constructor for the test suite exists
     * @throws IllegalAccessException    if the test case or constructor of the test suite is
     *                                   inaccessible
     * @throws InstantiationException    if the test suite could not be instantiated
     * @throws InvocationTargetException if the constructor throws an exception
     */
    private void execute(final String testCase, final Class&lt;?&gt; testSuite)
            throws NoSuchMethodException, IllegalAccessException, InstantiationException,
            InvocationTargetException {
<span class="nc" id="L291">        execute(testSuite.getDeclaredMethod(testCase), newInstanceOf(testSuite));</span>
<span class="nc" id="L292">    }</span>

    /**
     * Returns a new instance of the give class.
     *
     * @param clazz the class to instantiate
     * @return new instance of {@code clazz}
     * @throws NoSuchMethodException     if no default constructor was found
     * @throws IllegalAccessException    if the constructor is inaccessible
     * @throws InvocationTargetException if the constructor throws an exception
     * @throws InstantiationException    if the class could not be instantiated
     */
    private Object newInstanceOf(final Class&lt;?&gt; clazz)
            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException,
            InstantiationException {
        // We just assume there's a default constructor that doesn't require parameters.
<span class="nc" id="L308">        final Constructor&lt;?&gt; ctor = clazz.getDeclaredConstructor();</span>
<span class="nc" id="L309">        ctor.setAccessible(true);</span>
<span class="nc" id="L310">        return ctor.newInstance();</span>
    }

    /**
     * Executes a test case on the given instance of the test suite.
     *
     * @param testCase  the test case to execute
     * @param testSuite the instance of the test suite on which to invoke the test case
     * @throws IllegalAccessException    if the test case is inaccessible
     */
    private void execute(final Method testCase, final Object testSuite)
            throws IllegalAccessException {
<span class="nc" id="L322">        testCase.setAccessible(true); // Make non-public tests accessible.</span>
        try {
<span class="nc" id="L324">            testCase.invoke(testSuite);</span>
<span class="nc" id="L325">        } catch (InvocationTargetException e) {</span>
            // Swallow exceptions thrown by the class under test.
<span class="nc" id="L327">        }</span>
<span class="nc" id="L328">    }</span>

    /**
     * Instruments the given class using the specified instrumenter and loads the instrumented class
     * using the specified class loader.
     *
     * @param clazz        to load
     * @param instrumenter with which to instrument
     * @param loader       with which to load the instrumented class
     * @throws IOException            if instrumentation failed
     * @throws ClassNotFoundException if the class was not found
     */
    private void instrumentAndLoad(final Class&lt;?&gt; clazz,
            final Instrumenter instrumenter,
            final MemoryClassLoader loader)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L344">        final String className = clazz.getName();</span>
<span class="nc" id="L345">        final byte[] instrumentedBytecode = instrument(className, instrumenter);</span>
<span class="nc" id="L346">        addDefinitionAndLoad(className, instrumentedBytecode, loader);</span>
<span class="nc" id="L347">    }</span>

    /**
     * Reloads a class using the given class loader.
     *
     * @param clazz the class to reload
     * @return the reloaded class
     * @throws ClassNotFoundException if the class was not found
     * @throws IOException            if an I/O error occurs
     */
    private Class&lt;?&gt; addDefinitionAndLoad(final Class&lt;?&gt; clazz, final MemoryClassLoader loader)
            throws ClassNotFoundException, IOException {
<span class="nc" id="L359">        final String className = clazz.getName();</span>
<span class="nc" id="L360">        final InputStream targetClass = getClassStream(className);</span>
<span class="nc" id="L361">        return addDefinitionAndLoad(className, targetClass.readAllBytes(), loader);</span>
    }

    /**
     * Defines and loads a class with the given name using the specified bytecode and classloader.
     *
     * @param className name of the class to load
     * @param bytecode  class definition to load
     * @param loader    with which to load the class definition
     * @return the loaded class
     * @throws ClassNotFoundException if the class was not found
     */
    private Class&lt;?&gt; addDefinitionAndLoad(final String className,
            final byte[] bytecode,
            final MemoryClassLoader loader)
            throws ClassNotFoundException {
<span class="nc" id="L377">        loader.addDefinition(className, bytecode);</span>
<span class="nc" id="L378">        return loader.loadClass(className);</span>
    }

    /**
     * Instruments the class with the given name using the given instrumenter.
     *
     * @param className    name of the class to instrument
     * @param instrumenter with which to instrument
     * @return instrumented byte code of the class
     * @throws IOException if instrumentation failed
     */
    private byte[] instrument(final String className, final Instrumenter instrumenter)
            throws IOException {
        final byte[] instrumentedBytecode;
<span class="nc" id="L392">        try (final InputStream originalCut = getClassStream(className)) {</span>
<span class="nc" id="L393">            instrumentedBytecode = instrumenter.instrument(originalCut, className);</span>
        }
<span class="nc" id="L395">        return instrumentedBytecode;</span>
    }

    /**
     * Gathers line coverage data from the given coverage builder and returns a boolean array where
     * every entry {@code array[i] == true} indicates that line {@code i} was covered.
     *
     * @param builder from which to gather information
     * @return coverage array as described above
     */
    private boolean[] getCoverageArray(final CoverageBuilder builder) {
<span class="nc" id="L406">        final var classes = builder.getClasses();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        assert classes.size() == 1 : &quot;There should only be coverage information about the CUT&quot;;</span>
<span class="nc" id="L408">        final var classCoverage = classes.iterator().next();</span>

<span class="nc" id="L410">        final int firstLine = classCoverage.getFirstLine();</span>
<span class="nc" id="L411">        final int lastLine = classCoverage.getLastLine();</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">        assert firstLine != -1 &amp;&amp; lastLine != -1 : &quot;no coverage information is present&quot;;</span>

<span class="nc" id="L414">        final int lines = classCoverage.getLineCounter().getTotalCount(); // # of non-empty lines</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        assert lines &gt; 0 : &quot;no coverage information is present&quot;;</span>
<span class="nc" id="L416">        final boolean[] coverage = new boolean[lines];</span>

        // For every non-empty line in the CUT, check if it was covered or not.
<span class="nc bnc" id="L419" title="All 4 branches missed.">        for (int i = firstLine, j = 0; i &lt;= lastLine &amp;&amp; j &lt; lines; i++) {</span>
<span class="nc" id="L420">            final int status = classCoverage.getLine(i).getStatus();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (status != ICounter.EMPTY) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                coverage[j++] = status != ICounter.NOT_COVERED;</span>
            }
        }

<span class="nc" id="L426">        return coverage;</span>
    }

    private int[] getNonEmptyLines(final CoverageBuilder builder) {
<span class="nc" id="L430">        final var classCoverage = builder.getClasses().iterator().next();</span>
<span class="nc" id="L431">        final int lines = classCoverage.getLineCounter().getTotalCount();</span>
<span class="nc" id="L432">        final int[] nonEmptyLines = new int[lines];</span>

<span class="nc" id="L434">        final int firstLine = classCoverage.getFirstLine();</span>
<span class="nc" id="L435">        final int lastLine = classCoverage.getLastLine();</span>
<span class="nc bnc" id="L436" title="All 4 branches missed.">        for (int i = firstLine, j = 0; i &lt;= lastLine &amp;&amp; j &lt; lines; i++) {</span>
<span class="nc" id="L437">            final int status = classCoverage.getLine(i).getStatus();</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (status != ICounter.EMPTY) {</span>
<span class="nc" id="L439">                nonEmptyLines[j++] = i;</span>
            }
        }

<span class="nc" id="L443">        return nonEmptyLines;</span>
    }

    private String dumpCoverageInfo() {
<span class="nc" id="L447">        final var sb = new StringBuilder();</span>
<span class="nc" id="L448">        sb.append(String.format(&quot;Coverage of %s by %s%n&quot;, classUnderTestName, testSuiteName));</span>

<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (!cached) {</span>
<span class="nc" id="L451">            sb.append(&quot; * Not measured yet!\n&quot;);</span>
<span class="nc" id="L452">            return sb.toString();</span>
        }

<span class="nc bnc" id="L455" title="All 2 branches missed.">        for (int i = 0; i &lt; testCases.length; i++) {</span>
<span class="nc" id="L456">            final String testCase = testCases[i];</span>
<span class="nc" id="L457">            sb.append(String.format(&quot; * %s%n&quot;, testCase));</span>

<span class="nc" id="L459">            final boolean[] coverage = coverageMatrix[i];</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            for (int j = 0; j &lt; coverage.length; j++) {</span>
<span class="nc" id="L461">                final boolean c = coverage[j];</span>
<span class="nc" id="L462">                final int line = sourceLineNumbers[j];</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                sb.append(String.format(&quot;    &gt; line %d: %s%n&quot;, line, c ? &quot;covered&quot; : &quot;MISSED&quot;));</span>
            }
        }

<span class="nc" id="L467">        return sb.toString();</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L472">        return dumpCoverageInfo();</span>
    }

    /**
     * Returns the class with the given name as an input stream of bytes.
     *
     * @param className name of the class
     * @return input stream of bytes for the specified class
     */
    private InputStream getClassStream(final String className) {
<span class="nc" id="L482">        final String resource = '/' + className.replace('.', '/') + &quot;.class&quot;;</span>
<span class="nc" id="L483">        return getClass().getResourceAsStream(resource);</span>
    }

    /**
     * A class loader that loads classes from in-memory data.
     */
<span class="nc" id="L489">    public static class MemoryClassLoader extends ClassLoader {</span>

<span class="nc" id="L491">        private final Map&lt;String, byte[]&gt; definitions = new HashMap&lt;&gt;();</span>

        /**
         * Adds an in-memory representation of a class.
         *
         * @param name  name of the class
         * @param bytes class definition
         */
        public void addDefinition(final String name, final byte[] bytes) {
<span class="nc" id="L500">            definitions.put(name, bytes);</span>
<span class="nc" id="L501">        }</span>

        @Override
        protected Class&lt;?&gt; loadClass(final String name, final boolean resolve)
                throws ClassNotFoundException {
<span class="nc" id="L506">            final byte[] bytes = definitions.get(name);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (bytes != null) {</span>
<span class="nc" id="L508">                return defineClass(name, bytes, 0, bytes.length);</span>
            }
<span class="nc" id="L510">            return super.loadClass(name, resolve);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>