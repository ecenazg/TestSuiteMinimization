<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AlgorithmBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Test-Suite-Minimisation</a> &gt; <a href="index.source.html" class="el_package">de.uni_passau.fim.se2.sbse.suite_minimisation.utils</a> &gt; <span class="el_source">AlgorithmBuilder.java</span></div><h1>AlgorithmBuilder.java</h1><pre class="source lang-java linenums">package de.uni_passau.fim.se2.sbse.suite_minimisation.utils;

import de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms.GeneticAlgorithm;
import de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms.NSGA2;
import de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms.RandomSearch;
import de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms.SearchAlgorithmType;
import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.Chromosome;
import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.ChromosomeGenerator;
import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.TestSuiteChromosome;
import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.TestSuiteChromosomeGenerator;
import de.uni_passau.fim.se2.sbse.suite_minimisation.crossover.SinglePointCrossover;
import de.uni_passau.fim.se2.sbse.suite_minimisation.fitness_functions.*;
import de.uni_passau.fim.se2.sbse.suite_minimisation.mutation.BitFlipMutation;
import de.uni_passau.fim.se2.sbse.suite_minimisation.selection.BinaryTournamentSelection;
import de.uni_passau.fim.se2.sbse.suite_minimisation.stopping_conditions.StoppingCondition;

import java.util.Random;

public class AlgorithmBuilder {

    /**
     * The default source randomness.
     */
    private final Random random;

    /**
     * The stopping condition to use.
     */
    private final StoppingCondition stoppingCondition;

    /**
     * The coverage matrix to use. Every row in the matrix represents a test case and every column
     * represents a line in the CUT. An entry {@code matrix[i][j] == true} indicates that test case
     * {@code i} covers line {@code j}. The matrix is rectangular.
     */
    private final boolean[][] coverageMatrix;

    /**
     * The number of test cases in the test suite (corresponds to the number of rows in the {@code
     * coverageMatrix} and the length of the {@code testCaseNames} array).
     */
    private final int numberTestCases;

    /**
     * The number of lines in the system under test (corresponds to the number of columns in the
     * {@code coverageMatrix}).
     */
    private final int numberLines;

    /**
     * A normalizing fitness function measuring the size of test suite chromosomes.
     */
    private final MinimizingFitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; sizeFF;

    /**
     * A normalizing fitness function measuring the coverage of test suite chromosomes.
     */
    private final MaximizingFitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; coverageFF;

    public AlgorithmBuilder(final Random random,
                            final StoppingCondition stoppingCondition,
<span class="fc" id="L62">                            final boolean[][] coverageMatrix) {</span>
<span class="fc" id="L63">        this.random = random;</span>
<span class="fc" id="L64">        this.stoppingCondition = stoppingCondition;</span>
<span class="fc" id="L65">        this.coverageMatrix = coverageMatrix;</span>
<span class="fc" id="L66">        this.numberLines = coverageMatrix[0].length;</span>
<span class="fc" id="L67">        this.numberTestCases = coverageMatrix.length;</span>
<span class="fc" id="L68">        this.sizeFF = makeTestSuiteSizeFitnessFunction();</span>
<span class="fc" id="L69">        this.coverageFF = makeTestSuiteCoverageFitnessFunction();</span>
<span class="fc" id="L70">    }</span>

    /**
     * Creates a new normalizing fitness function that measures the size of a given test suite chromosome.
     *
     * @return the test suite size fitness function
     * @apiNote The return type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
     * couldn't specify it.
     * @implSpec When implementing this method, you can instantiate your custom subclasses such as
     * {@code FitnessFunction} as usual. No need to use the wildcard type &quot;{@code ?}&quot; yourself. The
     * fitness function shall be normalizing. The overall number of test cases can be retrieved from
     * the `numberTestCases` field.
     */
    private MinimizingFitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; makeTestSuiteSizeFitnessFunction() {

<span class="fc" id="L86">        return (MinimizingFitnessFunction&lt;Chromosome&lt;?&gt;&gt;) chromosome -&gt; {</span>
            // We know this is our concrete chromosome
<span class="nc" id="L88">            TestSuiteChromosome c = (TestSuiteChromosome) chromosome;</span>

<span class="nc" id="L90">            int selectedTests = c.getNumberOfSelectedTests();</span>

            // Normalized to [0, 1]
<span class="nc" id="L93">            return (double) selectedTests / numberTestCases;</span>
        };
    }


    /**
     * Creates a new normalizing fitness function that measures the coverage of a given test suite chromosome.
     *
     * @return the test suite coverage fitness function
     * @apiNote The return type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
     * couldn't specify it.
     * @implSpec When implementing this method, you can instantiate your custom subclasses such as
     * {@code FitnessFunction} as usual. No need to use the wildcard type &quot;{@code ?}&quot; yourself. The
     * fitness function shall be normalizing. The overall number of lines in the SUT
     * (system-under-test) can be retrieved from the `numberLines` field.
     */
    private MaximizingFitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; makeTestSuiteCoverageFitnessFunction() {

<span class="fc" id="L112">        return (MaximizingFitnessFunction&lt;Chromosome&lt;?&gt;&gt;) chromosome -&gt; {</span>
<span class="nc" id="L113">            TestSuiteChromosome c = (TestSuiteChromosome) chromosome;</span>

<span class="nc" id="L115">            boolean[] covered = new boolean[numberLines];</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">            for (int testIndex : c.getSelectedTestIndices()) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                for (int line = 0; line &lt; numberLines; line++) {</span>
<span class="nc" id="L119">                    covered[line] |= coverageMatrix[testIndex][line];</span>
                }
<span class="nc" id="L121">            }</span>

<span class="nc" id="L123">            int coveredLines = 0;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            for (boolean b : covered) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                if (b) coveredLines++;</span>
            }

            // Normalized to [0, 1]
<span class="nc" id="L129">            return (double) coveredLines / numberLines;</span>
        };
    }


    public MinimizingFitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; getSizeFF() {
<span class="fc" id="L135">        return sizeFF;</span>
    }

    public MaximizingFitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; getCoverageFF() {
<span class="fc" id="L139">        return coverageFF;</span>
    }

    /**
     * Builds the specified search algorithm using the fields of this class.
     *
     * @param algorithm the algorithm to build
     * @return the algorithm
     * @apiNote The return type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
     * couldn't specify it.
     */
    public GeneticAlgorithm&lt;? extends Chromosome&lt;?&gt;&gt; buildAlgorithm(final SearchAlgorithmType algorithm) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">        return switch (algorithm) {</span>
<span class="fc" id="L153">            case RANDOM_SEARCH -&gt; buildRandomSearch();</span>
<span class="fc" id="L154">            case NSGA_II -&gt; buildNSGA2();</span>
        };
    }

    /**
     * Returns an instance of the NSGA-II search algorithm to find a solution for the test suite
     * minimization problem. The algorithm is constructed using the fields of this class.
     *
     * @return the search algorithm
     * @apiNote The return type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
     * couldn't specify it.
     * @implSpec When implementing this method, you can instantiate your custom subclasses such as
     * {@code Mutation}, {@code Chromosome}, and {@code SearchAlgorithm} as usual. No need to use
     * the wildcard type &quot;{@code ?}&quot; yourself. However, depending on the circumstances it might be
     * necessary to add unchecked casts, e.g., when using the fitness function fields of this
     * class.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private GeneticAlgorithm&lt;? extends Chromosome&lt;?&gt;&gt; buildNSGA2() {

<span class="fc" id="L175">        var mutation = new BitFlipMutation();</span>
<span class="fc" id="L176">        var crossover = new SinglePointCrossover();</span>

<span class="fc" id="L178">        ChromosomeGenerator&lt;TestSuiteChromosome&gt; generator =</span>
                new TestSuiteChromosomeGenerator(numberTestCases, mutation, crossover);

<span class="fc" id="L181">        NSGA2 nsga2 = new NSGA2(</span>
                stoppingCondition,
                random,
                50,
                generator,
                (FitnessFunction&lt;TestSuiteChromosome&gt;) sizeFF,
                (FitnessFunction&lt;TestSuiteChromosome&gt;) coverageFF
        );

<span class="fc" id="L190">        var selection = new BinaryTournamentSelection&lt;TestSuiteChromosome&gt;(</span>
<span class="fc" id="L191">                nsga2.nsga2Comparator(),</span>
                random
        );

<span class="fc" id="L195">        return new NSGA2(</span>
                stoppingCondition,
                random,
                50,
                generator,
                (FitnessFunction&lt;TestSuiteChromosome&gt;) sizeFF,
                (FitnessFunction&lt;TestSuiteChromosome&gt;) coverageFF
        );
    }


    /**
     * Returns an instance of the Random Search algorithm to find a solution for the test suite
     * minimization problem. The algorithm is constructed using the fields of this class.
     * &lt;p&gt;
     * Instead of sampling a number of test suites at random and simply returning the best one, we
     * consider all sampled test suites and determine all non-dominated ones, according to the
     * objectives of line coverage and test suite size. This non-dominated set of solutions
     * represents the first Pareto-front.
     * &lt;p&gt;
     * Note: The more samples to take, the longer it takes for Random Search to run. At some
     * point, random search will run considerably longer than NSGA-II because the run time is
     * dominated by fast non-dominated sort, which runs in O(samples * samples).
     *
     * @return the search algorithm
     * @apiNote The return type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
     * couldn't specify it.
     * @implSpec When implementing this method, you can instantiate your custom subclasses such as
     * {@code Mutation}, {@code Chromosome}, and {@code SearchAlgorithm} as usual. No need to use
     * the wildcard type &quot;{@code ?}&quot; yourself. However, depending on the circumstances it might be
     * necessary to add unchecked casts, e.g., when using the fitness function fields of this
     * class.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private GeneticAlgorithm&lt;? extends Chromosome&lt;?&gt;&gt; buildRandomSearch() {

<span class="fc" id="L232">        var mutation = new BitFlipMutation();</span>
<span class="fc" id="L233">        var crossover = new SinglePointCrossover();</span>

<span class="fc" id="L235">        ChromosomeGenerator&lt;TestSuiteChromosome&gt; generator =</span>
                new TestSuiteChromosomeGenerator(numberTestCases, mutation, crossover);

<span class="fc" id="L238">        return new RandomSearch(</span>
                stoppingCondition,
                generator,
                (FitnessFunction&lt;TestSuiteChromosome&gt;) sizeFF,
                (FitnessFunction&lt;TestSuiteChromosome&gt;) coverageFF,
                coverageMatrix,
                numberTestCases,
                numberLines
        );

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>