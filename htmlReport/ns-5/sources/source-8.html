


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > IntHashMap</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">de.uni_passau.fim.se2.sbse.suite_minimisation.examples</a>
</div>

<h1>Coverage Summary for Class: IntHashMap (de.uni_passau.fim.se2.sbse.suite_minimisation.examples)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IntHashMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/83)
  </span>
</td>
</tr>
  <tr>
    <td class="name">IntHashMap$Entry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/88)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package de.uni_passau.fim.se2.sbse.suite_minimisation.examples;
&nbsp;
&nbsp;/**
&nbsp; * A hash map that uses primitive ints for the key rather than objects.
&nbsp; */
&nbsp;public class IntHashMap {
&nbsp;
&nbsp;    /**
&nbsp;     * The hash table data.
&nbsp;     */
&nbsp;    private Entry table[];
&nbsp;
&nbsp;    /**
&nbsp;     * The total number of entries in the hash table.
&nbsp;     */
&nbsp;    private int count;
&nbsp;
&nbsp;    /**
&nbsp;     * The table is rehashed when its size exceeds this threshold.  (The value of this field is
&nbsp;     * (int)(capacity * loadFactor).)
&nbsp;     */
&nbsp;    private int threshold;
&nbsp;
&nbsp;    /**
&nbsp;     * The load factor for the hashtable.
&nbsp;     */
&nbsp;    private float loadFactor;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a new, empty hashtable with a default capacity and load factor, which is 20 and
&nbsp;     * 0.75 respectively.
&nbsp;     */
&nbsp;    public IntHashMap() {
<b class="nc">&nbsp;        this(20, 0.75f);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a new, empty hashtable with the specified initial capacity and default load
&nbsp;     * factor, which is 0.75.
&nbsp;     *
&nbsp;     * @param initialCapacity the initial capacity of the hashtable.
&nbsp;     * @throws IllegalArgumentException if the initial capacity is less than zero.
&nbsp;     */
&nbsp;    public IntHashMap(int initialCapacity) {
<b class="nc">&nbsp;        this(initialCapacity, 0.75f);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a new, empty hashtable with the specified initial capacity and the specified load
&nbsp;     * factor.
&nbsp;     *
&nbsp;     * @param initialCapacity the initial capacity of the hashtable.
&nbsp;     * @param loadFactor      the load factor of the hashtable.
&nbsp;     * @throws IllegalArgumentException if the initial capacity is less than zero, or if the load
&nbsp;     *                                  factor is nonpositive.
&nbsp;     */
&nbsp;    public IntHashMap(int initialCapacity, float loadFactor) {
<b class="nc">&nbsp;        super();</b>
<b class="nc">&nbsp;        if (initialCapacity &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (loadFactor &lt;= 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Illegal Load: &quot; + loadFactor);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (initialCapacity == 0) {</b>
<b class="nc">&nbsp;            initialCapacity = 1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        this.loadFactor = loadFactor;</b>
<b class="nc">&nbsp;        table = new Entry[initialCapacity];</b>
<b class="nc">&nbsp;        threshold = (int) (initialCapacity * loadFactor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of keys in this hashtable.
&nbsp;     *
&nbsp;     * @return the number of keys in this hashtable.
&nbsp;     */
&nbsp;    public int size() {
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tests if this hashtable maps no keys to values.
&nbsp;     *
&nbsp;     * @return true if this hashtable maps no keys to values; false otherwise.
&nbsp;     */
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;        return count == 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tests if some key maps into the specified value in this hashtable. This operation is more
&nbsp;     * expensive than the containsKey method.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note that this method is identical in functionality to containsValue, (which is part of the
&nbsp;     * Map interface in the collections framework).
&nbsp;     *
&nbsp;     * @param value a value to search for.
&nbsp;     * @return true if and only if some key maps to the value argument in this hashtable as
&nbsp;     * determined by the equals method; false otherwise.
&nbsp;     * @throws NullPointerException if the value is null.
&nbsp;     * @see #containsKey(int)
&nbsp;     * @see #containsValue(Object)
&nbsp;     * @see java.util.Map
&nbsp;     */
&nbsp;    public boolean contains(Object value) {
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            throw new NullPointerException();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Entry tab[] = table;</b>
<b class="nc">&nbsp;        for (int i = tab.length; i-- &gt; 0; ) {</b>
<b class="nc">&nbsp;            for (Entry e = tab[i]; e != null; e = e.next) {</b>
<b class="nc">&nbsp;                if (e.value.equals(value)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this HashMap maps one or more keys to this value.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note that this method is identical in functionality to contains (which predates the Map
&nbsp;     * interface).
&nbsp;     *
&nbsp;     * @param value value whose presence in this HashMap is to be tested.
&nbsp;     * @see java.util.Map
&nbsp;     * @since JDK1.2
&nbsp;     */
&nbsp;    public boolean containsValue(Object value) {
<b class="nc">&nbsp;        return contains(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tests if the specified object is a key in this hashtable.
&nbsp;     *
&nbsp;     * @param key possible key.
&nbsp;     * @return true if and only if the specified object is a key in this hashtable, as determined by
&nbsp;     * the equals method; false otherwise.
&nbsp;     * @see #contains(Object)
&nbsp;     */
&nbsp;    public boolean containsKey(int key) {
<b class="nc">&nbsp;        Entry tab[] = table;</b>
<b class="nc">&nbsp;        int hash = key;</b>
<b class="nc">&nbsp;        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</b>
<b class="nc">&nbsp;        for (Entry e = tab[index]; e != null; e = e.next) {</b>
<b class="nc">&nbsp;            if (e.hash == hash) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value to which the specified key is mapped in this map.
&nbsp;     *
&nbsp;     * @param key a key in the hashtable.
&nbsp;     * @return the value to which the key is mapped in this hashtable; null if the key is not mapped
&nbsp;     * to any value in this hashtable.
&nbsp;     * @see #put(int, Object)
&nbsp;     */
&nbsp;    public Object get(int key) {
<b class="nc">&nbsp;        Entry tab[] = table;</b>
<b class="nc">&nbsp;        int hash = key;</b>
<b class="nc">&nbsp;        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</b>
<b class="nc">&nbsp;        for (Entry e = tab[index]; e != null; e = e.next) {</b>
<b class="nc">&nbsp;            if (e.hash == hash) {</b>
<b class="nc">&nbsp;                return e.value;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Increases the capacity of and internally reorganizes this hashtable, in order to accommodate
&nbsp;     * and access its entries more efficiently.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is called automatically when the number of keys in the hashtable exceeds this
&nbsp;     * hashtable&#39;s capacity and load factor.
&nbsp;     */
&nbsp;    protected void rehash() {
<b class="nc">&nbsp;        int oldCapacity = table.length;</b>
<b class="nc">&nbsp;        Entry oldMap[] = table;</b>
&nbsp;
<b class="nc">&nbsp;        int newCapacity = oldCapacity * 2 + 1;</b>
<b class="nc">&nbsp;        Entry newMap[] = new Entry[newCapacity];</b>
&nbsp;
<b class="nc">&nbsp;        threshold = (int) (newCapacity * loadFactor);</b>
<b class="nc">&nbsp;        table = newMap;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = oldCapacity; i-- &gt; 0; ) {</b>
<b class="nc">&nbsp;            for (Entry old = oldMap[i]; old != null; ) {</b>
<b class="nc">&nbsp;                Entry e = old;</b>
<b class="nc">&nbsp;                old = old.next;</b>
&nbsp;
<b class="nc">&nbsp;                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</b>
<b class="nc">&nbsp;                e.next = newMap[index];</b>
<b class="nc">&nbsp;                newMap[index] = e;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Maps the specified key to the specified value in this hashtable. The key cannot be null.
&nbsp;     * &lt;p&gt;
&nbsp;     * The value can be retrieved by calling the get method with a key that is equal to the original
&nbsp;     * key.
&nbsp;     *
&nbsp;     * @param key   the hashtable key.
&nbsp;     * @param value the value.
&nbsp;     * @return the previous value of the specified key in this hashtable, or null if it did not have
&nbsp;     * one.
&nbsp;     * @throws NullPointerException if the key is null.
&nbsp;     * @see #get(int)
&nbsp;     */
&nbsp;    public Object put(int key, Object value) {
&nbsp;        // Makes sure the key is not already in the hashtable.
<b class="nc">&nbsp;        Entry tab[] = table;</b>
<b class="nc">&nbsp;        int hash = key;</b>
<b class="nc">&nbsp;        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</b>
<b class="nc">&nbsp;        for (Entry e = tab[index]; e != null; e = e.next) {</b>
<b class="nc">&nbsp;            if (e.hash == hash) {</b>
<b class="nc">&nbsp;                Object old = e.value;</b>
<b class="nc">&nbsp;                e.value = value;</b>
<b class="nc">&nbsp;                return old;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (count &gt;= threshold) {</b>
&nbsp;            // Rehash the table if the threshold is exceeded
<b class="nc">&nbsp;            rehash();</b>
&nbsp;
<b class="nc">&nbsp;            tab = table;</b>
<b class="nc">&nbsp;            index = (hash &amp; 0x7FFFFFFF) % tab.length;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Creates the new entry.
<b class="nc">&nbsp;        Entry e = new Entry(hash, key, value, tab[index]);</b>
<b class="nc">&nbsp;        tab[index] = e;</b>
<b class="nc">&nbsp;        count++;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the key (and its corresponding value) from this hashtable.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method does nothing if the key is not present in the hashtable.
&nbsp;     *
&nbsp;     * @param key the key that needs to be removed.
&nbsp;     * @return the value to which the key had been mapped in this hashtable, or null if the key did
&nbsp;     * not have a mapping.
&nbsp;     */
&nbsp;    public Object remove(int key) {
<b class="nc">&nbsp;        Entry tab[] = table;</b>
<b class="nc">&nbsp;        int hash = key;</b>
<b class="nc">&nbsp;        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</b>
<b class="nc">&nbsp;        for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next) {</b>
<b class="nc">&nbsp;            if (e.hash == hash) {</b>
<b class="nc">&nbsp;                if (prev != null) {</b>
<b class="nc">&nbsp;                    prev.next = e.next;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    tab[index] = e.next;</b>
&nbsp;                }
<b class="nc">&nbsp;                count--;</b>
<b class="nc">&nbsp;                Object oldValue = e.value;</b>
<b class="nc">&nbsp;                e.value = null;</b>
<b class="nc">&nbsp;                return oldValue;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clears this hashtable so that it contains no keys.
&nbsp;     */
&nbsp;    public void clear() {
<b class="nc">&nbsp;        Entry tab[] = table;</b>
<b class="nc">&nbsp;        for (int index = tab.length; --index &gt;= 0; ) {</b>
<b class="nc">&nbsp;            tab[index] = null;</b>
&nbsp;        }
<b class="nc">&nbsp;        count = 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Innerclass that acts as a datastructure to create a new entry in the table.
&nbsp;     */
&nbsp;    private static class Entry {
&nbsp;
&nbsp;        int hash;
&nbsp;        int key;
&nbsp;        Object value;
&nbsp;        Entry next;
&nbsp;
&nbsp;        /**
&nbsp;         * Create a new entry with the given values.
&nbsp;         *
&nbsp;         * @param hash  The code used to hash the object with
&nbsp;         * @param key   The key used to enter this in the table
&nbsp;         * @param value The value for this key
&nbsp;         * @param next  A reference to the next entry in the table
&nbsp;         */
<b class="nc">&nbsp;        protected Entry(int hash, int key, Object value, Entry next) {</b>
<b class="nc">&nbsp;            this.hash = hash;</b>
<b class="nc">&nbsp;            this.key = key;</b>
<b class="nc">&nbsp;            this.value = value;</b>
<b class="nc">&nbsp;            this.next = next;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-13 22:10</div>
</div>
</body>
</html>
