


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > SparseIntArray</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">de.uni_passau.fim.se2.sbse.suite_minimisation.examples</a>
</div>

<h1>Coverage Summary for Class: SparseIntArray (de.uni_passau.fim.se2.sbse.suite_minimisation.examples)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SparseIntArray</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/91)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package de.uni_passau.fim.se2.sbse.suite_minimisation.examples;
&nbsp;
&nbsp;/**
&nbsp; * SparseIntArrays map integers to integers.  Unlike a normal array of integers, there can be gaps
&nbsp; * in the indices.  It is intended to be more memory efficient than using a HashMap to map Integers
&nbsp; * to Integers, both because it avoids auto-boxing keys and values and its data structure doesn&#39;t
&nbsp; * rely on an extra entry object for each mapping.
&nbsp; *
&nbsp; * &lt;p&gt;Note that this container keeps its mappings in an array data structure,
&nbsp; * using a binary search to find keys.  The implementation is not intended to be appropriate for
&nbsp; * data structures that may contain large numbers of items.  It is generally slower than a
&nbsp; * traditional HashMap, since lookups require a binary search and adds and removes require inserting
&nbsp; * and deleting entries in the array.  For containers holding up to hundreds of items, the
&nbsp; * performance difference is not significant, less than 50%.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;It is possible to iterate over the items in this container using
&nbsp; * {@link #keyAt(int)} and {@link #valueAt(int)}. Iterating over the keys using
&nbsp; * &lt;code&gt;keyAt(int)&lt;/code&gt; with ascending values of the index will return the
&nbsp; * keys in ascending order, or the values corresponding to the keys in ascending order in the case
&nbsp; * of &lt;code&gt;valueAt(int)&lt;/code&gt;.&lt;/p&gt;
&nbsp; */
&nbsp;public class SparseIntArray implements Cloneable {
&nbsp;
<b class="nc">&nbsp;    private static final int[] EMPTY_INT_ARRAY = new int[0];</b>
&nbsp;    private int[] mKeys;
&nbsp;    private int[] mValues;
&nbsp;    private int mSize;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new SparseIntArray containing no mappings.
&nbsp;     */
&nbsp;    public SparseIntArray() {
<b class="nc">&nbsp;        this(10);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new SparseIntArray containing no mappings that will not require any additional
&nbsp;     * memory allocation to store the specified number of mappings.  If you supply an initial
&nbsp;     * capacity of 0, the sparse array will be initialized with a light-weight representation not
&nbsp;     * requiring any additional array allocations.
&nbsp;     */
<b class="nc">&nbsp;    public SparseIntArray(int initialCapacity) {</b>
<b class="nc">&nbsp;        if (initialCapacity == 0) {</b>
<b class="nc">&nbsp;            mKeys = SparseIntArray.EMPTY_INT_ARRAY;</b>
<b class="nc">&nbsp;            mValues = SparseIntArray.EMPTY_INT_ARRAY;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            mKeys = new int[initialCapacity];</b>
<b class="nc">&nbsp;            mValues = new int[mKeys.length];</b>
&nbsp;        }
<b class="nc">&nbsp;        mSize = 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Given the current size of an array, returns an ideal size to which the array should grow.
&nbsp;     * This is typically double the given size, but should not be relied upon to do so in the
&nbsp;     * future.
&nbsp;     */
&nbsp;    public static int growSize(int currentSize) {
<b class="nc">&nbsp;        return currentSize &lt;= 4 ? 8 : currentSize + (currentSize &gt;&gt; 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SparseIntArray clone() {
<b class="nc">&nbsp;        SparseIntArray clone = null;</b>
&nbsp;        try {
<b class="nc">&nbsp;            clone = (SparseIntArray) super.clone();</b>
<b class="nc">&nbsp;            clone.mKeys = mKeys.clone();</b>
<b class="nc">&nbsp;            clone.mValues = mValues.clone();</b>
&nbsp;        } catch (CloneNotSupportedException cnse) {
&nbsp;            /* ignore */
&nbsp;        }
<b class="nc">&nbsp;        return clone;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the int mapped from the specified key, or &lt;code&gt;0&lt;/code&gt; if no such mapping has been
&nbsp;     * made.
&nbsp;     */
&nbsp;    public int get(int key) {
<b class="nc">&nbsp;        return get(key, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the int mapped from the specified key, or the specified value if no such mapping has
&nbsp;     * been made.
&nbsp;     */
&nbsp;    public int get(int key, int valueIfKeyNotFound) {
<b class="nc">&nbsp;        int i = binarySearch(mKeys, mSize, key);</b>
&nbsp;
<b class="nc">&nbsp;        if (i &lt; 0) {</b>
<b class="nc">&nbsp;            return valueIfKeyNotFound;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return mValues[i];</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the mapping from the specified key, if there was any.
&nbsp;     */
&nbsp;    public void delete(int key) {
<b class="nc">&nbsp;        int i = binarySearch(mKeys, mSize, key);</b>
&nbsp;
<b class="nc">&nbsp;        if (i &gt;= 0) {</b>
<b class="nc">&nbsp;            removeAt(i);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the mapping at the given index.
&nbsp;     */
&nbsp;    public void removeAt(int index) {
<b class="nc">&nbsp;        System.arraycopy(mKeys, index + 1, mKeys, index, mSize - (index + 1));</b>
<b class="nc">&nbsp;        System.arraycopy(mValues, index + 1, mValues, index, mSize - (index + 1));</b>
<b class="nc">&nbsp;        --mSize;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a mapping from the specified key to the specified value, replacing the previous mapping
&nbsp;     * from the specified key if there was one.
&nbsp;     */
&nbsp;    public void put(int key, int value) {
<b class="nc">&nbsp;        int i = binarySearch(mKeys, mSize, key);</b>
&nbsp;
<b class="nc">&nbsp;        if (i &gt;= 0) {</b>
<b class="nc">&nbsp;            mValues[i] = value;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            i = ~i;</b>
<b class="nc">&nbsp;            mKeys = insertElementIntoIntArray(mKeys, mSize, i, key);</b>
<b class="nc">&nbsp;            mValues = insertElementIntoIntArray(mValues, mSize, i, value);</b>
<b class="nc">&nbsp;            ++mSize;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of key-value mappings that this SparseIntArray currently stores.
&nbsp;     */
&nbsp;    public int size() {
<b class="nc">&nbsp;        return mSize;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Given an index in the range &lt;code&gt;0...size()-1&lt;/code&gt;, returns the key from the
&nbsp;     * &lt;code&gt;index&lt;/code&gt;th key-value mapping that this SparseIntArray stores.
&nbsp;     *
&nbsp;     * &lt;p&gt;The keys corresponding to indices in ascending order are guaranteed to
&nbsp;     * be in ascending order, e.g., &lt;code&gt;keyAt(0)&lt;/code&gt; will return the smallest key and
&nbsp;     * &lt;code&gt;keyAt(size()-1)&lt;/code&gt; will return the largest key.&lt;/p&gt;
&nbsp;     */
&nbsp;    public int keyAt(int index) {
<b class="nc">&nbsp;        return mKeys[index];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Given an index in the range &lt;code&gt;0...size()-1&lt;/code&gt;, returns the value from the
&nbsp;     * &lt;code&gt;index&lt;/code&gt;th key-value mapping that this SparseIntArray stores.
&nbsp;     *
&nbsp;     * &lt;p&gt;The values corresponding to indices in ascending order are guaranteed
&nbsp;     * to be associated with keys in ascending order, e.g.,
&nbsp;     * &lt;code&gt;valueAt(0)&lt;/code&gt; will return the value associated with the
&nbsp;     * smallest key and &lt;code&gt;valueAt(size()-1)&lt;/code&gt; will return the value associated with the
&nbsp;     * largest key.&lt;/p&gt;
&nbsp;     */
&nbsp;    public int valueAt(int index) {
<b class="nc">&nbsp;        return mValues[index];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the index for which {@link #keyAt} would return the specified key, or a negative
&nbsp;     * number if the specified key is not mapped.
&nbsp;     */
&nbsp;    public int indexOfKey(int key) {
<b class="nc">&nbsp;        return binarySearch(mKeys, mSize, key);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an index for which {@link #valueAt} would return the specified key, or a negative
&nbsp;     * number if no keys map to the specified value. Beware that this is a linear search, unlike
&nbsp;     * lookups by key, and that multiple keys can map to the same value and this will find only one
&nbsp;     * of them.
&nbsp;     */
&nbsp;    public int indexOfValue(int value) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; mSize; ++i) {</b>
<b class="nc">&nbsp;            if (mValues[i] == value) {</b>
<b class="nc">&nbsp;                return i;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all key-value mappings from this SparseIntArray.
&nbsp;     */
&nbsp;    public void clear() {
<b class="nc">&nbsp;        mSize = 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Puts a key/value pair into the array, optimizing for the case where the key is greater than
&nbsp;     * all existing keys in the array.
&nbsp;     */
&nbsp;    public void append(int key, int value) {
<b class="nc">&nbsp;        if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) {</b>
<b class="nc">&nbsp;            put(key, value);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        mKeys = appendElementIntoIntArray(mKeys, mSize, key);</b>
<b class="nc">&nbsp;        mValues = appendElementIntoIntArray(mValues, mSize, value);</b>
<b class="nc">&nbsp;        mSize++;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int binarySearch(int[] array, int size, int value) {
<b class="nc">&nbsp;        int lo = 0;</b>
<b class="nc">&nbsp;        int hi = size - 1;</b>
&nbsp;
<b class="nc">&nbsp;        while (lo &lt;= hi) {</b>
<b class="nc">&nbsp;            int mid = (lo + hi) &gt;&gt;&gt; 1;</b>
<b class="nc">&nbsp;            int midVal = array[mid];</b>
&nbsp;
<b class="nc">&nbsp;            if (midVal &lt; value) {</b>
<b class="nc">&nbsp;                lo = mid + 1;</b>
<b class="nc">&nbsp;            } else if (midVal &gt; value) {</b>
<b class="nc">&nbsp;                hi = mid - 1;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return mid;  // value found</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return ~lo;  // value not present</b>
&nbsp;    }
&nbsp;
&nbsp;    private int[] appendElementIntoIntArray(int[] array, int currentSize, int element) {
<b class="nc">&nbsp;        if (currentSize &gt; array.length) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Bad currentSize, originalSize: &quot; + array.length + &quot; currentSize: &quot;
&nbsp;                            + currentSize);
&nbsp;        }
<b class="nc">&nbsp;        if (currentSize + 1 &gt; array.length) {</b>
<b class="nc">&nbsp;            int[] newArray = new int[SparseIntArray.growSize(currentSize)];</b>
<b class="nc">&nbsp;            System.arraycopy(array, 0, newArray, 0, currentSize);</b>
<b class="nc">&nbsp;            array = newArray;</b>
&nbsp;        }
<b class="nc">&nbsp;        array[currentSize] = element;</b>
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int[] insertElementIntoIntArray(int[] array, int currentSize, int index, int element) {
<b class="nc">&nbsp;        if (currentSize &gt; array.length) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Bad currentSize, originalSize: &quot; + array.length + &quot; currentSize: &quot;
&nbsp;                            + currentSize);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (currentSize + 1 &lt;= array.length) {</b>
<b class="nc">&nbsp;            System.arraycopy(array, index, array, index + 1, currentSize - index);</b>
<b class="nc">&nbsp;            array[index] = element;</b>
<b class="nc">&nbsp;            return array;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int[] newArray = new int[SparseIntArray.growSize(currentSize)];</b>
<b class="nc">&nbsp;        System.arraycopy(array, 0, newArray, 0, index);</b>
<b class="nc">&nbsp;        newArray[index] = element;</b>
<b class="nc">&nbsp;        System.arraycopy(array, index, newArray, index + 1, array.length - index);</b>
<b class="nc">&nbsp;        return newArray;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     *
&nbsp;     * &lt;p&gt;This implementation composes a string by iterating over its mappings.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        if (size() &lt;= 0) {</b>
<b class="nc">&nbsp;            return &quot;{}&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        StringBuilder buffer = new StringBuilder(mSize * 28);</b>
<b class="nc">&nbsp;        buffer.append(&#39;{&#39;);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; mSize; i++) {</b>
<b class="nc">&nbsp;            if (i &gt; 0) {</b>
<b class="nc">&nbsp;                buffer.append(&quot;, &quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            int key = keyAt(i);</b>
<b class="nc">&nbsp;            buffer.append(key);</b>
<b class="nc">&nbsp;            buffer.append(&#39;=&#39;);</b>
<b class="nc">&nbsp;            int value = valueAt(i);</b>
<b class="nc">&nbsp;            buffer.append(value);</b>
&nbsp;        }
<b class="nc">&nbsp;        buffer.append(&#39;}&#39;);</b>
<b class="nc">&nbsp;        return buffer.toString();</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-13 22:10</div>
</div>
</body>
</html>
