


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AlgorithmConverter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">de.uni_passau.fim.se2.sbse.suite_minimisation</a>
</div>

<h1>Coverage Summary for Class: AlgorithmConverter (de.uni_passau.fim.se2.sbse.suite_minimisation)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AlgorithmConverter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package de.uni_passau.fim.se2.sbse.suite_minimisation;
&nbsp;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms.GeneticAlgorithm;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.algorithms.SearchAlgorithmType;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.Chromosome;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.chromosomes.TestSuiteChromosome;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.fitness_functions.FitnessFunction;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.stopping_conditions.MaxFitnessEvaluations;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.stopping_conditions.StoppingCondition;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.utils.AlgorithmBuilder;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.utils.CoverageTracker;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.utils.Randomness;
&nbsp;import de.uni_passau.fim.se2.sbse.suite_minimisation.utils.Utils;
&nbsp;import picocli.CommandLine;
&nbsp;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.Callable;
&nbsp;
&nbsp;import static java.util.stream.Collectors.summarizingDouble;
&nbsp;
&nbsp;public class Main implements Callable&lt;Integer&gt; {
&nbsp;
&nbsp;    @CommandLine.Option(
&nbsp;            names = {&quot;-c&quot;, &quot;--class&quot;},
&nbsp;            description = &quot;The name of the class under test.&quot;,
&nbsp;            required = true)
&nbsp;    private String className;
&nbsp;
&nbsp;    @CommandLine.Option(
&nbsp;            names = {&quot;-p&quot;, &quot;--package&quot;},
&nbsp;            description = &quot;The package containing the class under test.&quot;,
&nbsp;            defaultValue = &quot;de.uni_passau.fim.se2.sbse.suite_minimisation.examples&quot;)
&nbsp;    private String packageName;
&nbsp;
&nbsp;    @CommandLine.Option(
&nbsp;            names = {&quot;-f&quot;, &quot;--max-evaluations&quot;},
&nbsp;            description = &quot;The maximum number of fitness evaluations.&quot;,
&nbsp;            defaultValue = &quot;1000&quot;)
&nbsp;    private int maxEvaluations;
&nbsp;
&nbsp;    @CommandLine.Option(
&nbsp;            names = {&quot;-r&quot;, &quot;--repetitions&quot;},
&nbsp;            description = &quot;The number of search repetitions to perform.&quot;,
&nbsp;            defaultValue = &quot;10&quot;)
&nbsp;    private int repetitions;
&nbsp;
&nbsp;    @CommandLine.Option(
&nbsp;            names = {&quot;-s&quot;, &quot;--seed&quot;},
&nbsp;            description = &quot;Use a fixed RNG seed.&quot;)
&nbsp;    public void setSeed(int seed) {
&nbsp;        Randomness.random().setSeed(seed);
&nbsp;    }
&nbsp;
&nbsp;    @CommandLine.Parameters(
&nbsp;            paramLabel = &quot;algorithms&quot;,
&nbsp;            description = &quot;The search algorithms to use.&quot;,
&nbsp;            arity = &quot;1...&quot;,
&nbsp;            converter = AlgorithmConverter.class)
&nbsp;    private List&lt;SearchAlgorithmType&gt; algorithms;
&nbsp;
&nbsp;    /**
&nbsp;     * The names of the test cases (corresponding to the coverage matrix). That is, for and index
&nbsp;     * {@code i}, {@code testCases[i]} tells the name of the ith test case and
&nbsp;     * {@code coverageMatrix[i]} tells which lines of code are covered by the ith test case.
&nbsp;     */
&nbsp;    private String[] testCases;
&nbsp;
&nbsp;    /**
&nbsp;     * The coverage matrix for the analyzed software system.
&nbsp;     */
&nbsp;    private boolean[][] coverageMatrix;
&nbsp;
&nbsp;    /**
&nbsp;     * Instance of the algorithm builder to create the search algorithms.
&nbsp;     */
&nbsp;    private AlgorithmBuilder algorithmBuilder;
&nbsp;
&nbsp;
&nbsp;    public static void main(String[] args) {
&nbsp;        int exitCode = new CommandLine(new Main()).execute(args);
&nbsp;        System.exit(exitCode);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Executes the specified search algorithms and prints a summary of the obtained results.
&nbsp;     *
&nbsp;     * @return The exit code of the application
&nbsp;     */
&nbsp;    public Integer call() {
&nbsp;        try {
&nbsp;            setCoverageMatrixAndTestCaseNames();
&nbsp;        } catch (Exception e) {
&nbsp;            System.err.println(&quot;Error while initializing coverage matrix and test case names.&quot;);
&nbsp;            return 1;
&nbsp;        }
&nbsp;        StoppingCondition stoppingCondition = MaxFitnessEvaluations.of(maxEvaluations);
&nbsp;        this.algorithmBuilder = new AlgorithmBuilder(Randomness.random(), stoppingCondition, coverageMatrix);
&nbsp;
&nbsp;        List&lt;AlgorithmStats&gt; results = startSearch();
&nbsp;        for (final AlgorithmStats result : results) {
&nbsp;            System.out.println(result);
&nbsp;        }
&nbsp;        return 0;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Starts the command line tool, running the specified algorithms and returns the results.
&nbsp;     *
&nbsp;     * @return the results
&nbsp;     */
&nbsp;    List&lt;AlgorithmStats&gt; startSearch() {
&nbsp;        final var algorithmStats = new ArrayList&lt;AlgorithmStats&gt;();
&nbsp;        for (final var algorithm : algorithms) {
&nbsp;            final GeneticAlgorithm&lt;? extends Chromosome&lt;?&gt;&gt; search = algorithmBuilder.buildAlgorithm(algorithm);
&nbsp;
&nbsp;            final long start = System.currentTimeMillis();
&nbsp;            final var stats = repeatSearch(search);
&nbsp;            final long totalTime = System.currentTimeMillis() - start;
&nbsp;            final double avgTime = (double) totalTime / repetitions;
&nbsp;
&nbsp;            algorithmStats.add(new AlgorithmStats(algorithm, stats, totalTime, avgTime));
&nbsp;        }
&nbsp;        return algorithmStats;
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;RepetitionStats&gt; repeatSearch(final GeneticAlgorithm&lt;? extends Chromosome&lt;?&gt;&gt; algorithm) {
&nbsp;        // Normalized fitness functions that compute the coverage and size of a test suite.
&nbsp;        final FitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; coverageFF = algorithmBuilder.getCoverageFF();
&nbsp;        final FitnessFunction&lt;? extends Chromosome&lt;?&gt;&gt; sizeFF = algorithmBuilder.getSizeFF();
&nbsp;
&nbsp;        // Coordinates for the reference point when computing the hyper-volume of a Pareto front.
&nbsp;        final double covRef = 0.0;  // worst possible coverage (0%)
&nbsp;        final double sizeRef = 1.0; // worst possible size (100%)
&nbsp;
&nbsp;        final var list = new ArrayList&lt;RepetitionStats&gt;(repetitions);
&nbsp;        for (int i = 1; i &lt;= repetitions; i++) {
&nbsp;            System.out.printf(&quot;Repetition %d/%d for algorithm %s\n&quot;, i, repetitions, algorithm);
&nbsp;            final List&lt;? extends Chromosome&lt;?&gt;&gt; testSuites = algorithm.findSolution();
&nbsp;            final double hyperVolume = Utils.computeHyperVolume(testSuites, coverageFF, sizeFF, covRef, sizeRef);
&nbsp;            final var testSuiteStats = makeTestSuiteStatsFrom(testSuites);
&nbsp;            final var repetitionStats = new RepetitionStats(i, testSuiteStats, hyperVolume);
&nbsp;            list.add(repetitionStats);
&nbsp;        }
&nbsp;        return list;
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;TestSuiteStats&gt; makeTestSuiteStatsFrom(
&nbsp;            final List&lt;? extends Chromosome&lt;?&gt;&gt; testSuites) {
&nbsp;        final var list = new ArrayList&lt;TestSuiteStats&gt;(testSuites.size());
&nbsp;        for (final Chromosome&lt;?&gt; testSuiteChromosome : testSuites) {
&nbsp;            list.add(makeTestSuiteStatsFrom(testSuiteChromosome));
&nbsp;        }
&nbsp;        return list;
&nbsp;    }
&nbsp;
&nbsp;    private TestSuiteStats makeTestSuiteStatsFrom(final Chromosome&lt;?&gt; testSuiteChromosome) {
&nbsp;        final List&lt;String&gt; testCaseNames = getTestCaseNamesFrom(testSuiteChromosome);
&nbsp;        final double coverage = getCoverageOf(testSuiteChromosome);
&nbsp;        final double size = getSizeOf(testSuiteChromosome);
&nbsp;        return new TestSuiteStats(testCaseNames, coverage, size);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extracts the test case names from the given test suite chromosome. This chromosome has been
&nbsp;     * generated and returned by your search algorithm as part of the Pareto-front. The chromosome
&nbsp;     * represents a test suite comprises a some test cases.
&nbsp;     *
&nbsp;     * @param testSuiteChromosome the test suite chromosome
&nbsp;     * @return the names of the test cases in the test suite represented by the chromosome
&nbsp;     * @apiNote The input type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
&nbsp;     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
&nbsp;     * couldn&#39;t specify it.
&nbsp;     * @implSpec The names of these test cases shall be retrieved from the {@code testCases}
&nbsp;     * array of this class. Due to the wildcard in the input type, you will need to downcast to your
&nbsp;     * custom chromosome type before you can do so.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    List&lt;String&gt; getTestCaseNamesFrom(final Chromosome&lt;?&gt; testSuiteChromosome) {
&nbsp;
&nbsp;        TestSuiteChromosome c = (TestSuiteChromosome) testSuiteChromosome;
&nbsp;
&nbsp;        List&lt;String&gt; names = new ArrayList&lt;&gt;();
&nbsp;
&nbsp;        for (int index : c.getSelectedTestIndices()) {
&nbsp;            names.add(testCases[index]);
&nbsp;        }
&nbsp;
&nbsp;        return names;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Takes the given test suite chromosome as input and returns its relative/normalized coverage.
&nbsp;     *
&nbsp;     * @param testSuiteChromosome the test suite chromosome
&nbsp;     * @return the relative coverage of the test suite
&nbsp;     * @apiNote The input type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
&nbsp;     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
&nbsp;     * couldn&#39;t specify it.
&nbsp;     * @implSpec As a consequence of the wildcard type, you&#39;ll need to downcast the
&nbsp;     * `testSuiteChromosome` to your own chromosome type. If you want to reuse the `coverageFF`
&nbsp;     * field of this class, you also need to cast the fitness function.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    double getCoverageOf(final Chromosome&lt;?&gt; testSuiteChromosome) {
&nbsp;
&nbsp;        FitnessFunction&lt;TestSuiteChromosome&gt; coverageFF =
&nbsp;                (FitnessFunction&lt;TestSuiteChromosome&gt;) algorithmBuilder.getCoverageFF();
&nbsp;
&nbsp;        return coverageFF.applyAsDouble((TestSuiteChromosome) testSuiteChromosome);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Takes the given test suite chromosome as input and returns its relative/normalized size.
&nbsp;     *
&nbsp;     * @param testSuiteChromosome the test suite chromosome
&nbsp;     * @return the relative size of the test suite
&nbsp;     * @apiNote The input type uses a wildcard type &quot;{@code ?}&quot;. This is because your custom
&nbsp;     * subclass of {@code Chromosome} has not existed yet at the time of writing this code, so I
&nbsp;     * couldn&#39;t specify it.
&nbsp;     * @implSpec As a consequence of the wildcard type, you&#39;ll need to downcast the
&nbsp;     * `testSuiteChromosome` to your own chromosome type. If you want to reuse the `sizeFF` field of
&nbsp;     * this class, you also need to cast the fitness function.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    double getSizeOf(final Chromosome&lt;?&gt; testSuiteChromosome) {
&nbsp;
&nbsp;        FitnessFunction&lt;TestSuiteChromosome&gt; sizeFF =
&nbsp;                (FitnessFunction&lt;TestSuiteChromosome&gt;) algorithmBuilder.getSizeFF();
&nbsp;
&nbsp;        return sizeFF.applyAsDouble((TestSuiteChromosome) testSuiteChromosome);
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes the coverage matrix and the test case names.
&nbsp;     *
&nbsp;     * @throws Exception if an error occurs while initializing the coverage matrix and the test case names
&nbsp;     */
&nbsp;    private void setCoverageMatrixAndTestCaseNames() throws Exception {
&nbsp;        final String fullyQualifiedClassName = packageName + &quot;.&quot; + className;
&nbsp;        CoverageTracker tracker = new CoverageTracker(fullyQualifiedClassName);
&nbsp;        this.coverageMatrix = tracker.getCoverageMatrix();
&nbsp;        this.testCases = tracker.getTestCases();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Formats the given duration in milliseconds as {@code HH:MM:SS:ssss}.
&nbsp;     *
&nbsp;     * @param durationInMillis the duration in milliseconds
&nbsp;     * @return the formatted duration
&nbsp;     */
&nbsp;    private static String formatTime(final long durationInMillis) {
&nbsp;        final long millis = durationInMillis % 1000;
&nbsp;        final long seconds = (durationInMillis / 1000) % 60;
&nbsp;        final long minutes = (durationInMillis / (1000 * 60)) % 60;
&nbsp;        final long hours = (durationInMillis / (1000 * 60 * 60)) % 24;
&nbsp;        return String.format(&quot;%02d:%02d:%02d.%d&quot;, hours, minutes, seconds, millis);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Formats the given duration in milliseconds as {@code HH:MM:SS:ssss}. The fractional part of
&nbsp;     * the duration is removed.
&nbsp;     *
&nbsp;     * @param fractionalMillis the duration
&nbsp;     * @return the formatted duration
&nbsp;     */
&nbsp;    private static String formatTime(final double fractionalMillis) {
&nbsp;        return formatTime((long) fractionalMillis);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Container class reporting statistics about test suites, namely the names of its test cases,
&nbsp;     * its coverage and size.
&nbsp;     */
&nbsp;    public record TestSuiteStats(List&lt;String&gt; testCaseNames, double coverage, double size) {
&nbsp;        private static final String INDENT2 = &quot; &quot;.repeat(RepetitionStats.INDENT1.length()) + &quot;&gt; &quot;;
&nbsp;        private static final String INDENT3 = &quot; &quot;.repeat(INDENT2.length());
&nbsp;
&nbsp;        public TestSuiteStats(
&nbsp;                final List&lt;String&gt; testCaseNames,
&nbsp;                final double coverage,
&nbsp;                final double size) {
&nbsp;            if (testCaseNames.isEmpty()) {
&nbsp;                throw new IllegalArgumentException(&quot;Expected a non-empty test suite&quot;);
&nbsp;            }
&nbsp;
&nbsp;            if (!(0.0 &lt;= coverage &amp;&amp; coverage &lt;= 1.0)) {
&nbsp;                throw new IllegalArgumentException(&quot;Expected normalized coverage: &quot; + coverage);
&nbsp;            }
&nbsp;
&nbsp;            if (!(0.0 &lt;= size &amp;&amp; size &lt;= 1.0)) {
&nbsp;                throw new IllegalArgumentException(&quot;Expected normalized size: &quot; + size);
&nbsp;            }
&nbsp;
&nbsp;            this.testCaseNames = new ArrayList&lt;&gt;(testCaseNames);
&nbsp;            this.testCaseNames.sort(null); // Sort test cases in lexicographical order.
&nbsp;            this.coverage = coverage;
&nbsp;            this.size = size;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
&nbsp;            return String.format(&quot;%sTest Suite: %s%n&quot;, INDENT2, testCaseNames)
&nbsp;                    + String.format(&quot;%sCoverage:   %s%n&quot;, INDENT3, coverage)
&nbsp;                    + String.format(&quot;%sSize:       %s%n&quot;, INDENT3, size);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public record RepetitionStats(int repetition, List&lt;TestSuiteStats&gt; testSuiteStats, double hyperVolume) {
&nbsp;
&nbsp;        private static final String INDENT1 = &quot; * &quot;;
&nbsp;        private static final Comparator&lt;TestSuiteStats&gt; byCoverage =
&nbsp;                Comparator.comparingDouble(ts -&gt; ts.coverage);
&nbsp;
&nbsp;        public RepetitionStats(
&nbsp;                final int repetition,
&nbsp;                final List&lt;TestSuiteStats&gt; testSuiteStats,
&nbsp;                final double hyperVolume) {
&nbsp;            if (!(0.0 &lt;= hyperVolume &amp;&amp; hyperVolume &lt;= 1.0)) {
&nbsp;                throw new IllegalArgumentException(&quot;Expected normalized hyper-volume: &quot;
&nbsp;                        + hyperVolume);
&nbsp;            }
&nbsp;
&nbsp;            this.testSuiteStats = new ArrayList&lt;&gt;(testSuiteStats);
&nbsp;            this.testSuiteStats.sort(byCoverage);
&nbsp;            this.repetition = repetition;
&nbsp;            this.hyperVolume = hyperVolume;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
&nbsp;            final var sb = new StringBuilder(
&nbsp;                    String.format(&quot;%sRepetition %d:\tHV %f\tFront Size %d%n&quot;,
&nbsp;                            INDENT1, repetition, hyperVolume, testSuiteStats.size()));
&nbsp;
&nbsp;            for (final var testSuiteStat : testSuiteStats) {
&nbsp;                sb.append(testSuiteStat.toString());
&nbsp;            }
&nbsp;
&nbsp;            return sb.toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static final class AlgorithmStats {
&nbsp;
&nbsp;        private final SearchAlgorithmType algorithm;
&nbsp;        private final List&lt;RepetitionStats&gt; repetitionStats;
&nbsp;        private final DoubleSummaryStatistics hyperVolumeStats;
&nbsp;        private final long totalTime;
&nbsp;        private final double avgTime;
&nbsp;
&nbsp;        public AlgorithmStats(
&nbsp;                final SearchAlgorithmType algorithm,
&nbsp;                final List&lt;RepetitionStats&gt; repetitionStats,
&nbsp;                final long totalTime,
&nbsp;                final double avgTime) {
&nbsp;            this.algorithm = algorithm;
&nbsp;            this.repetitionStats = repetitionStats;
&nbsp;            this.hyperVolumeStats = repetitionStats.stream()
&nbsp;                    .collect(summarizingDouble(stat -&gt; stat.hyperVolume));
&nbsp;            this.totalTime = totalTime;
&nbsp;            this.avgTime = avgTime;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
&nbsp;            final var sb = new StringBuilder(&quot;Results for &quot; + algorithm);
&nbsp;
&nbsp;            for (final var repetitionStat : repetitionStats) {
&nbsp;                sb.append(repetitionStat.toString());
&nbsp;            }
&nbsp;
&nbsp;            sb.append(&quot;Summary:\n&quot;);
&nbsp;            sb.append(String.format(&quot;%s (hyper volumes):\tavg: %f\tmin: %f\tmax:%f%n&quot;,
&nbsp;                    algorithm,
&nbsp;                    hyperVolumeStats.getAverage(),
&nbsp;                    hyperVolumeStats.getMin(),
&nbsp;                    hyperVolumeStats.getMax()));
&nbsp;            sb.append(String.format(&quot;%s (time):\ttotal: %s\tavg: %s%n&quot;,
&nbsp;                    algorithm,
&nbsp;                    formatTime(totalTime),
&nbsp;                    formatTime(avgTime)));
&nbsp;
&nbsp;            return sb.toString();
&nbsp;        }
&nbsp;
&nbsp;        public DoubleSummaryStatistics getHyperVolumeStats() {
&nbsp;            return hyperVolumeStats;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Converts supplied cli parameters to the respective {@link SearchAlgorithmType}.
&nbsp; */
<b class="fc">&nbsp;final class AlgorithmConverter implements CommandLine.ITypeConverter&lt;SearchAlgorithmType&gt; {</b>
&nbsp;    @Override
&nbsp;    public SearchAlgorithmType convert(String algorithm) {
<b class="nc">&nbsp;        return switch (algorithm.toUpperCase()) {</b>
<b class="nc">&nbsp;            case &quot;RS&quot; -&gt; SearchAlgorithmType.RANDOM_SEARCH;</b>
<b class="nc">&nbsp;            case &quot;NSGA2&quot; -&gt; SearchAlgorithmType.NSGA_II;</b>
<b class="nc">&nbsp;            default -&gt; throw new IllegalArgumentException(&quot;The algorithm &#39;&quot; + algorithm + &quot;&#39; is not a valid option.&quot;);</b>
&nbsp;        };
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-13 22:10</div>
</div>
</body>
</html>
