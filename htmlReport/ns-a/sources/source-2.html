


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CoverageTracker</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">de.uni_passau.fim.se2.sbse.suite_minimisation.utils</a>
</div>

<h1>Coverage Summary for Class: CoverageTracker (de.uni_passau.fim.se2.sbse.suite_minimisation.utils)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CoverageTracker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/110)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CoverageTracker$MemoryClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/117)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* ******************************************************************************
&nbsp; * Copyright (c) 2009, 2020 Mountainminds GmbH &amp; Co. KG and Contributors
&nbsp; * This program and the accompanying materials are made available under
&nbsp; * the terms of the Eclipse Public License 2.0 which is available at
&nbsp; * http://www.eclipse.org/legal/epl-2.0
&nbsp; *
&nbsp; * SPDX-License-Identifier: EPL-2.0
&nbsp; *
&nbsp; * Contributors:
&nbsp; *    Marc R. Hoffmann - initial API and implementation
&nbsp; *
&nbsp; * https://www.jacoco.org/jacoco/trunk/doc/api.html
&nbsp; * https://www.jacoco.org/jacoco/trunk/doc/examples/java/CoreTutorial.java
&nbsp; *******************************************************************************/
&nbsp;
&nbsp;package de.uni_passau.fim.se2.sbse.suite_minimisation.utils;
&nbsp;
&nbsp;import org.jacoco.core.analysis.Analyzer;
&nbsp;import org.jacoco.core.analysis.CoverageBuilder;
&nbsp;import org.jacoco.core.analysis.ICounter;
&nbsp;import org.jacoco.core.data.ExecutionDataStore;
&nbsp;import org.jacoco.core.data.SessionInfoStore;
&nbsp;import org.jacoco.core.instr.Instrumenter;
&nbsp;import org.jacoco.core.runtime.LoggerRuntime;
&nbsp;import org.jacoco.core.runtime.RuntimeData;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;/**
&nbsp; * Measures code coverage of a class under test by a given test suite.
&nbsp; */
<b class="nc">&nbsp;public final class CoverageTracker {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Annotation with which a JUnit 5 test case is marked.
&nbsp;     */
<b class="nc">&nbsp;    private static final Class&lt;? extends Annotation&gt; JUNIT5_TEST = org.junit.jupiter.api.Test.class;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Default suffix appended to the name of the CUT to obtain the name of its test suite.
&nbsp;     */
&nbsp;    private static final String DEFAULT_TEST_SUFFIX = &quot;Test&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The class under test (often abbreviated as &quot;CUT&quot;).
&nbsp;     */
&nbsp;    private final Class&lt;?&gt; classUnderTest;
&nbsp;
&nbsp;    /**
&nbsp;     * Name of the class under test.
&nbsp;     */
&nbsp;    private final String classUnderTestName;
&nbsp;
&nbsp;    /**
&nbsp;     * The test suite. Consists of test cases.
&nbsp;     */
&nbsp;    private final Class&lt;?&gt; testSuite;
&nbsp;
&nbsp;    /**
&nbsp;     * Name of the test suite.
&nbsp;     */
&nbsp;    private final String testSuiteName;
&nbsp;
&nbsp;    /**
&nbsp;     * Method names of the test cases in the test suite.
&nbsp;     */
&nbsp;    private final String[] testCases;
&nbsp;
&nbsp;    /**
&nbsp;     * The coverage matrix. Lazily instantiated and cached. Every line corresponds to a test case.
&nbsp;     * Every row corresponds to a line in the source code of the CUT. An entry in the matrix is
&nbsp;     * {@code true} if the corresponding test covers the corresponding line.
&nbsp;     */
&nbsp;    private final boolean[][] coverageMatrix;
&nbsp;
&nbsp;    /**
&nbsp;     * The line numbers in the source code. Lazily instantiated and cached.
&nbsp;     */
&nbsp;    private int[] sourceLineNumbers;
&nbsp;
&nbsp;    /**
&nbsp;     * Whether coverage has already been measured. Used for caching.
&nbsp;     */
&nbsp;    private boolean cached;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instance for tracking the coverage of the given class under test by the
&nbsp;     * specified test suite.
&nbsp;     *
&nbsp;     * @param classUnderTest class whose coverage to measure
&nbsp;     * @param testSuite      corresponding test suite
&nbsp;     */
<b class="nc">&nbsp;    public CoverageTracker(final Class&lt;?&gt; classUnderTest, final Class&lt;?&gt; testSuite) {</b>
<b class="nc">&nbsp;        this.classUnderTest = Objects.requireNonNull(classUnderTest);</b>
<b class="nc">&nbsp;        this.classUnderTestName = classUnderTest.getName();</b>
<b class="nc">&nbsp;        this.testSuite = Objects.requireNonNull(testSuite);</b>
<b class="nc">&nbsp;        this.testSuiteName = testSuite.getName();</b>
<b class="nc">&nbsp;        this.testCases = getTestCases(testSuite);</b>
<b class="nc">&nbsp;        this.coverageMatrix = new boolean[testCases.length][];</b>
<b class="nc">&nbsp;        this.sourceLineNumbers = null;</b>
<b class="nc">&nbsp;        this.cached = false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instance for tracking the coverage of the given class under test, attempting
&nbsp;     * to determine the corresponding test suite automatically.
&nbsp;     *
&nbsp;     * @param classUnderTestName fully-qualified name of the class whose coverage to measure
&nbsp;     * @throws ClassNotFoundException if a class could not be found
&nbsp;     */
&nbsp;    public CoverageTracker(final String classUnderTestName) throws ClassNotFoundException {
<b class="nc">&nbsp;        this(load(classUnderTestName), load(getTestSuiteName(classUnderTestName)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Attempts to load and return the class with the given fully-qualified name.
&nbsp;     *
&nbsp;     * @param className name of the class to load
&nbsp;     * @return the loaded class
&nbsp;     * @throws ClassNotFoundException if the class with the given name could not be found
&nbsp;     */
&nbsp;    private static Class&lt;?&gt; load(final String className) throws ClassNotFoundException {
<b class="nc">&nbsp;        return Class.forName(className);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of the test suite for the given class under test.
&nbsp;     *
&nbsp;     * @param classUnderTestName name of the class for which to return the name of its test suite
&nbsp;     * @return name of the test suite
&nbsp;     */
&nbsp;    private static String getTestSuiteName(final String classUnderTestName) {
<b class="nc">&nbsp;        return classUnderTestName + DEFAULT_TEST_SUFFIX;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves the test cases from the given test suite.
&nbsp;     *
&nbsp;     * @param testSuite a test suite
&nbsp;     * @return test cases
&nbsp;     */
&nbsp;    private static String[] getTestCases(final Class&lt;?&gt; testSuite) {
<b class="nc">&nbsp;        final Method[] declaredMethods = testSuite.getDeclaredMethods();</b>
<b class="nc">&nbsp;        return Arrays.stream(declaredMethods)</b>
<b class="nc">&nbsp;                .filter(CoverageTracker::isTestCase)</b>
<b class="nc">&nbsp;                .map(Method::getName)</b>
<b class="nc">&nbsp;                .sorted() // to impose a fixed order (here: lexicographical order)</b>
<b class="nc">&nbsp;                .toArray(String[]::new);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the test cases of the test suite this {@code CoverageTracker} was constructed with.
&nbsp;     * The test cases follow the same order as in the coverage matrix returned by {@code
&nbsp;     * getCoverageMatrix()}.
&nbsp;     *
&nbsp;     * @return the test cases
&nbsp;     */
&nbsp;    public String[] getTestCases() {
<b class="nc">&nbsp;        return testCases;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether the given method is a unit test.
&nbsp;     *
&nbsp;     * @param method the method to test
&nbsp;     * @return {@code true} if {@code method} is a unit test, {@code false} otherwise
&nbsp;     */
&nbsp;    private static boolean isTestCase(final Method method) {
<b class="nc">&nbsp;        return method.isAnnotationPresent(JUNIT5_TEST);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns line coverage of the CUT as coverage matrix. Hereby, every row in the matrix
&nbsp;     * represents a test case and every column represents a line in the CUT. An entry {@code
&nbsp;     * matrix[i][j] == true} indicates that test case {@code i} covers line {@code j}. The matrix is
&nbsp;     * rectangular.
&nbsp;     *
&nbsp;     * @return coverage matrix as described above
&nbsp;     * @throws Exception if an error occurred
&nbsp;     */
&nbsp;    public boolean[][] getCoverageMatrix() throws Exception {
<b class="nc">&nbsp;        if (!cached) {</b>
<b class="nc">&nbsp;            measureCoverage();</b>
<b class="nc">&nbsp;            assert isRectangularMatrix() : &quot;coverage matrix is not rectangular&quot;;</b>
<b class="nc">&nbsp;            cached = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return coverageMatrix;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tells whether the coverage matrix is rectangular.
&nbsp;     *
&nbsp;     * @return {@code true} if rectangular, {@code false} otherwise
&nbsp;     */
&nbsp;    private boolean isRectangularMatrix() {
<b class="nc">&nbsp;        boolean rectangular = true;</b>
<b class="nc">&nbsp;        for (int i = 0; rectangular &amp;&amp; i &lt; coverageMatrix.length - 1; ) {</b>
&nbsp;            // All rows in the matrix must have the same length.
<b class="nc">&nbsp;            rectangular = coverageMatrix[i++].length == coverageMatrix[i].length;</b>
&nbsp;        }
<b class="nc">&nbsp;        return rectangular;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Measures the line coverage of the CUT achieved by all unit tests in the test suite.
&nbsp;     *
&nbsp;     * @throws Exception if some error occurred
&nbsp;     */
&nbsp;    private void measureCoverage() throws Exception {
<b class="nc">&nbsp;        for (int i = 0; i &lt; testCases.length; i++) {</b>
<b class="nc">&nbsp;            final String testCase = testCases[i];</b>
<b class="nc">&nbsp;            final boolean[] coverage = measureCoverage(testCase);</b>
<b class="nc">&nbsp;            coverageMatrix[i] = coverage;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Measures the line coverage of the CUT achieved by the specified unit test and returns a
&nbsp;     * boolean array. An entry in the array is {@code true} if the corresponding line was covered.
&nbsp;     *
&nbsp;     * @param testCase for which to measure coverage
&nbsp;     * @throws Exception if an error occurred
&nbsp;     */
&nbsp;    private boolean[] measureCoverage(final String testCase) throws Exception {
&nbsp;        // For instrumentation and runtime we need an IRuntime instance to collect execution data.
<b class="nc">&nbsp;        final var coverageReporter = new LoggerRuntime();</b>
&nbsp;
&nbsp;        // The instrumenter creates a modified version of our class under test that contains
&nbsp;        // additional probes for execution data recording.
<b class="nc">&nbsp;        final var coverageInstrumenter = new Instrumenter(coverageReporter);</b>
&nbsp;
&nbsp;        // We use a special class loader to directly load the instrumented class definitions from
&nbsp;        // byte[] instances.
<b class="nc">&nbsp;        final var loader = new MemoryClassLoader();</b>
<b class="nc">&nbsp;        instrumentAndLoad(classUnderTest, coverageInstrumenter, loader);</b>
&nbsp;
&nbsp;        // Now we&#39;re ready to run our instrumented class and need to start the runtime first.
<b class="nc">&nbsp;        final var runtimeData = new RuntimeData();</b>
<b class="nc">&nbsp;        coverageReporter.startup(runtimeData);</b>
&nbsp;
&nbsp;        // We execute the test case via Java reflection. The test suite must have benn loaded with
&nbsp;        // the same class loader as the class under test.
<b class="nc">&nbsp;        execute(testCase, addDefinitionAndLoad(testSuite, loader));</b>
&nbsp;
&nbsp;        // At the end of test execution we collect execution data and shutdown the runtime.
<b class="nc">&nbsp;        final var executionData = new ExecutionDataStore();</b>
<b class="nc">&nbsp;        runtimeData.collect(executionData, new SessionInfoStore(), false);</b>
<b class="nc">&nbsp;        coverageReporter.shutdown();</b>
&nbsp;
&nbsp;        // Together with the original class definition we can calculate coverage information.
<b class="nc">&nbsp;        final var coverageBuilder = new CoverageBuilder();</b>
<b class="nc">&nbsp;        final var analyzer = new Analyzer(executionData, coverageBuilder);</b>
<b class="nc">&nbsp;        try (final InputStream originalCut = getClassStream(classUnderTestName)) {</b>
<b class="nc">&nbsp;            analyzer.analyzeClass(originalCut, classUnderTestName);</b>
&nbsp;        }
&nbsp;
&nbsp;        // (Just for debugging purposes: record the original line numbers of the source file.)
<b class="nc">&nbsp;        if (sourceLineNumbers == null) {</b>
<b class="nc">&nbsp;            sourceLineNumbers = getNonEmptyLines(coverageBuilder);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Finally, we build and return the coverage array.
<b class="nc">&nbsp;        return getCoverageArray(coverageBuilder);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Executes the test case part of the given test suite.
&nbsp;     *
&nbsp;     * @param testCase  the test case to execute
&nbsp;     * @param testSuite the test suite containing the test case
&nbsp;     * @throws NoSuchMethodException     if no test case with the given name or no default
&nbsp;     *                                   constructor for the test suite exists
&nbsp;     * @throws IllegalAccessException    if the test case or constructor of the test suite is
&nbsp;     *                                   inaccessible
&nbsp;     * @throws InstantiationException    if the test suite could not be instantiated
&nbsp;     * @throws InvocationTargetException if the constructor throws an exception
&nbsp;     */
&nbsp;    private void execute(final String testCase, final Class&lt;?&gt; testSuite)
&nbsp;            throws NoSuchMethodException, IllegalAccessException, InstantiationException,
&nbsp;            InvocationTargetException {
<b class="nc">&nbsp;        execute(testSuite.getDeclaredMethod(testCase), newInstanceOf(testSuite));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new instance of the give class.
&nbsp;     *
&nbsp;     * @param clazz the class to instantiate
&nbsp;     * @return new instance of {@code clazz}
&nbsp;     * @throws NoSuchMethodException     if no default constructor was found
&nbsp;     * @throws IllegalAccessException    if the constructor is inaccessible
&nbsp;     * @throws InvocationTargetException if the constructor throws an exception
&nbsp;     * @throws InstantiationException    if the class could not be instantiated
&nbsp;     */
&nbsp;    private Object newInstanceOf(final Class&lt;?&gt; clazz)
&nbsp;            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException,
&nbsp;            InstantiationException {
&nbsp;        // We just assume there&#39;s a default constructor that doesn&#39;t require parameters.
<b class="nc">&nbsp;        final Constructor&lt;?&gt; ctor = clazz.getDeclaredConstructor();</b>
<b class="nc">&nbsp;        ctor.setAccessible(true);</b>
<b class="nc">&nbsp;        return ctor.newInstance();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Executes a test case on the given instance of the test suite.
&nbsp;     *
&nbsp;     * @param testCase  the test case to execute
&nbsp;     * @param testSuite the instance of the test suite on which to invoke the test case
&nbsp;     * @throws IllegalAccessException    if the test case is inaccessible
&nbsp;     */
&nbsp;    private void execute(final Method testCase, final Object testSuite)
&nbsp;            throws IllegalAccessException {
<b class="nc">&nbsp;        testCase.setAccessible(true); // Make non-public tests accessible.</b>
&nbsp;        try {
<b class="nc">&nbsp;            testCase.invoke(testSuite);</b>
&nbsp;        } catch (InvocationTargetException e) {
&nbsp;            // Swallow exceptions thrown by the class under test.
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruments the given class using the specified instrumenter and loads the instrumented class
&nbsp;     * using the specified class loader.
&nbsp;     *
&nbsp;     * @param clazz        to load
&nbsp;     * @param instrumenter with which to instrument
&nbsp;     * @param loader       with which to load the instrumented class
&nbsp;     * @throws IOException            if instrumentation failed
&nbsp;     * @throws ClassNotFoundException if the class was not found
&nbsp;     */
&nbsp;    private void instrumentAndLoad(final Class&lt;?&gt; clazz,
&nbsp;            final Instrumenter instrumenter,
&nbsp;            final MemoryClassLoader loader)
&nbsp;            throws IOException, ClassNotFoundException {
<b class="nc">&nbsp;        final String className = clazz.getName();</b>
<b class="nc">&nbsp;        final byte[] instrumentedBytecode = instrument(className, instrumenter);</b>
<b class="nc">&nbsp;        addDefinitionAndLoad(className, instrumentedBytecode, loader);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reloads a class using the given class loader.
&nbsp;     *
&nbsp;     * @param clazz the class to reload
&nbsp;     * @return the reloaded class
&nbsp;     * @throws ClassNotFoundException if the class was not found
&nbsp;     * @throws IOException            if an I/O error occurs
&nbsp;     */
&nbsp;    private Class&lt;?&gt; addDefinitionAndLoad(final Class&lt;?&gt; clazz, final MemoryClassLoader loader)
&nbsp;            throws ClassNotFoundException, IOException {
<b class="nc">&nbsp;        final String className = clazz.getName();</b>
<b class="nc">&nbsp;        final InputStream targetClass = getClassStream(className);</b>
<b class="nc">&nbsp;        return addDefinitionAndLoad(className, targetClass.readAllBytes(), loader);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines and loads a class with the given name using the specified bytecode and classloader.
&nbsp;     *
&nbsp;     * @param className name of the class to load
&nbsp;     * @param bytecode  class definition to load
&nbsp;     * @param loader    with which to load the class definition
&nbsp;     * @return the loaded class
&nbsp;     * @throws ClassNotFoundException if the class was not found
&nbsp;     */
&nbsp;    private Class&lt;?&gt; addDefinitionAndLoad(final String className,
&nbsp;            final byte[] bytecode,
&nbsp;            final MemoryClassLoader loader)
&nbsp;            throws ClassNotFoundException {
<b class="nc">&nbsp;        loader.addDefinition(className, bytecode);</b>
<b class="nc">&nbsp;        return loader.loadClass(className);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instruments the class with the given name using the given instrumenter.
&nbsp;     *
&nbsp;     * @param className    name of the class to instrument
&nbsp;     * @param instrumenter with which to instrument
&nbsp;     * @return instrumented byte code of the class
&nbsp;     * @throws IOException if instrumentation failed
&nbsp;     */
&nbsp;    private byte[] instrument(final String className, final Instrumenter instrumenter)
&nbsp;            throws IOException {
&nbsp;        final byte[] instrumentedBytecode;
<b class="nc">&nbsp;        try (final InputStream originalCut = getClassStream(className)) {</b>
<b class="nc">&nbsp;            instrumentedBytecode = instrumenter.instrument(originalCut, className);</b>
&nbsp;        }
<b class="nc">&nbsp;        return instrumentedBytecode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gathers line coverage data from the given coverage builder and returns a boolean array where
&nbsp;     * every entry {@code array[i] == true} indicates that line {@code i} was covered.
&nbsp;     *
&nbsp;     * @param builder from which to gather information
&nbsp;     * @return coverage array as described above
&nbsp;     */
&nbsp;    private boolean[] getCoverageArray(final CoverageBuilder builder) {
<b class="nc">&nbsp;        final var classes = builder.getClasses();</b>
<b class="nc">&nbsp;        assert classes.size() == 1 : &quot;There should only be coverage information about the CUT&quot;;</b>
<b class="nc">&nbsp;        final var classCoverage = classes.iterator().next();</b>
&nbsp;
<b class="nc">&nbsp;        final int firstLine = classCoverage.getFirstLine();</b>
<b class="nc">&nbsp;        final int lastLine = classCoverage.getLastLine();</b>
<b class="nc">&nbsp;        assert firstLine != -1 &amp;&amp; lastLine != -1 : &quot;no coverage information is present&quot;;</b>
&nbsp;
<b class="nc">&nbsp;        final int lines = classCoverage.getLineCounter().getTotalCount(); // # of non-empty lines</b>
<b class="nc">&nbsp;        assert lines &gt; 0 : &quot;no coverage information is present&quot;;</b>
<b class="nc">&nbsp;        final boolean[] coverage = new boolean[lines];</b>
&nbsp;
&nbsp;        // For every non-empty line in the CUT, check if it was covered or not.
<b class="nc">&nbsp;        for (int i = firstLine, j = 0; i &lt;= lastLine &amp;&amp; j &lt; lines; i++) {</b>
<b class="nc">&nbsp;            final int status = classCoverage.getLine(i).getStatus();</b>
<b class="nc">&nbsp;            if (status != ICounter.EMPTY) {</b>
<b class="nc">&nbsp;                coverage[j++] = status != ICounter.NOT_COVERED;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return coverage;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int[] getNonEmptyLines(final CoverageBuilder builder) {
<b class="nc">&nbsp;        final var classCoverage = builder.getClasses().iterator().next();</b>
<b class="nc">&nbsp;        final int lines = classCoverage.getLineCounter().getTotalCount();</b>
<b class="nc">&nbsp;        final int[] nonEmptyLines = new int[lines];</b>
&nbsp;
<b class="nc">&nbsp;        final int firstLine = classCoverage.getFirstLine();</b>
<b class="nc">&nbsp;        final int lastLine = classCoverage.getLastLine();</b>
<b class="nc">&nbsp;        for (int i = firstLine, j = 0; i &lt;= lastLine &amp;&amp; j &lt; lines; i++) {</b>
<b class="nc">&nbsp;            final int status = classCoverage.getLine(i).getStatus();</b>
<b class="nc">&nbsp;            if (status != ICounter.EMPTY) {</b>
<b class="nc">&nbsp;                nonEmptyLines[j++] = i;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return nonEmptyLines;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String dumpCoverageInfo() {
<b class="nc">&nbsp;        final var sb = new StringBuilder();</b>
<b class="nc">&nbsp;        sb.append(String.format(&quot;Coverage of %s by %s%n&quot;, classUnderTestName, testSuiteName));</b>
&nbsp;
<b class="nc">&nbsp;        if (!cached) {</b>
<b class="nc">&nbsp;            sb.append(&quot; * Not measured yet!\n&quot;);</b>
<b class="nc">&nbsp;            return sb.toString();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; testCases.length; i++) {</b>
<b class="nc">&nbsp;            final String testCase = testCases[i];</b>
<b class="nc">&nbsp;            sb.append(String.format(&quot; * %s%n&quot;, testCase));</b>
&nbsp;
<b class="nc">&nbsp;            final boolean[] coverage = coverageMatrix[i];</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; coverage.length; j++) {</b>
<b class="nc">&nbsp;                final boolean c = coverage[j];</b>
<b class="nc">&nbsp;                final int line = sourceLineNumbers[j];</b>
<b class="nc">&nbsp;                sb.append(String.format(&quot;    &gt; line %d: %s%n&quot;, line, c ? &quot;covered&quot; : &quot;MISSED&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        return dumpCoverageInfo();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the class with the given name as an input stream of bytes.
&nbsp;     *
&nbsp;     * @param className name of the class
&nbsp;     * @return input stream of bytes for the specified class
&nbsp;     */
&nbsp;    private InputStream getClassStream(final String className) {
<b class="nc">&nbsp;        final String resource = &#39;/&#39; + className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;</b>
<b class="nc">&nbsp;        return getClass().getResourceAsStream(resource);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class loader that loads classes from in-memory data.
&nbsp;     */
<b class="nc">&nbsp;    public static class MemoryClassLoader extends ClassLoader {</b>
&nbsp;
<b class="nc">&nbsp;        private final Map&lt;String, byte[]&gt; definitions = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Adds an in-memory representation of a class.
&nbsp;         *
&nbsp;         * @param name  name of the class
&nbsp;         * @param bytes class definition
&nbsp;         */
&nbsp;        public void addDefinition(final String name, final byte[] bytes) {
<b class="nc">&nbsp;            definitions.put(name, bytes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Class&lt;?&gt; loadClass(final String name, final boolean resolve)
&nbsp;                throws ClassNotFoundException {
<b class="nc">&nbsp;            final byte[] bytes = definitions.get(name);</b>
<b class="nc">&nbsp;            if (bytes != null) {</b>
<b class="nc">&nbsp;                return defineClass(name, bytes, 0, bytes.length);</b>
&nbsp;            }
<b class="nc">&nbsp;            return super.loadClass(name, resolve);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-13 22:10</div>
</div>
</body>
</html>
